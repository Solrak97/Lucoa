Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> declaration
Rule 2     program -> program declaration
Rule 3     program -> function_definition
Rule 4     program -> iteration_statement
Rule 5     program -> selection_statement
Rule 6     declaration -> init_declarator SEMICOLON
Rule 7     init_declarator -> declarator
Rule 8     init_declarator -> declarator EQUALS assignment_expression
Rule 9     declarator -> LET IDENTIFIER COLON type_specifier
Rule 10    declarator -> CONST IDENTIFIER COLON type_specifier
Rule 11    type_specifier -> VOID
Rule 12    type_specifier -> CHAR
Rule 13    type_specifier -> INT
Rule 14    type_specifier -> FLOAT
Rule 15    type_specifier -> STRING
Rule 16    type_specifier -> BOOL
Rule 17    literal -> INT_LITERAL
Rule 18    literal -> FLOAT_LITERAL
Rule 19    literal -> STRING_LITERAL
Rule 20    primary_expression -> IDENTIFIER
Rule 21    primary_expression -> literal
Rule 22    additive_expression -> primary_expression
Rule 23    additive_expression -> additive_expression PLUS primary_expression
Rule 24    additive_expression -> additive_expression MINUS primary_expression
Rule 25    multiplicative_expression -> additive_expression
Rule 26    multiplicative_expression -> multiplicative_expression MUL additive_expression
Rule 27    multiplicative_expression -> multiplicative_expression DIV additive_expression
Rule 28    assignment_expression -> multiplicative_expression
Rule 29    assignment_expression -> primary_expression EQUALS multiplicative_expression
Rule 30    selection_statement -> IF conditional_expression compound_statement
Rule 31    selection_statement -> IF conditional_expression compound_statement ELSE compound_statement
Rule 32    statement -> declaration
Rule 33    statement -> iteration_statement
Rule 34    statement -> selection_statement
Rule 35    statement_list -> statement
Rule 36    statement_list -> statement_list statement
Rule 37    compound_statement -> CUR_PAR_OPEN CUR_PAR_CLOSE
Rule 38    compound_statement -> CUR_PAR_OPEN statement_list CUR_PAR_CLOSE
Rule 39    identifier_list -> IDENTIFIER
Rule 40    identifier_list -> identifier_list COMMA IDENTIFIER
Rule 41    relational_expression -> multiplicative_expression
Rule 42    relational_expression -> relational_expression LESS_OP multiplicative_expression
Rule 43    relational_expression -> relational_expression GREATER_OP multiplicative_expression
Rule 44    relational_expression -> relational_expression LE_OP multiplicative_expression
Rule 45    relational_expression -> relational_expression GE_OP multiplicative_expression
Rule 46    equality_expression -> relational_expression
Rule 47    equality_expression -> equality_expression EQ_OP relational_expression
Rule 48    equality_expression -> equality_expression NE_OP relational_expression
Rule 49    and_expression -> equality_expression
Rule 50    and_expression -> and_expression AND_OP equality_expression
Rule 51    or_expression -> and_expression
Rule 52    or_expression -> or_expression OR_OP and_expression
Rule 53    conditional_expression -> or_expression
Rule 54    conditional_expression -> or_expression QUESTION assignment_expression COLON conditional_expression
Rule 55    function_definition -> FUNC IDENTIFIER RND_PAR_OPEN identifier_list RND_PAR_CLOSE ARROW type_specifier compound_statement
Rule 56    iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON INC_OP compound_statement
Rule 57    iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON DEC_OP compound_statement
Rule 58    iteration_statement -> WHILE conditional_expression compound_statement
Rule 59    iteration_statement -> DO compound_statement WHILE conditional_expression SEMICOLON

Terminals, with rules where they appear

AND_OP               : 50
ARROW                : 55
BOOL                 : 16
BOX_PAR_CLOSE        : 56 57
BOX_PAR_OPEN         : 56 57
CHAR                 : 12
COLON                : 9 10 54 56 57
COMMA                : 40 56 57
CONST                : 10
CUR_PAR_CLOSE        : 37 38
CUR_PAR_OPEN         : 37 38
DEC_OP               : 57
DIV                  : 27
DO                   : 59
ELSE                 : 31
EQUALS               : 8 29
EQ_OP                : 47
FLOAT                : 14
FLOAT_LITERAL        : 18
FROM                 : 56 57
FUNC                 : 55
GE_OP                : 45
GREATER_OP           : 43
IDENTIFIER           : 9 10 20 39 40 55
IF                   : 30 31
INC_OP               : 56
INT                  : 13
INT_LITERAL          : 17
LESS_OP              : 42
LET                  : 9
LE_OP                : 44
MINUS                : 24
MUL                  : 26
NE_OP                : 48
OR_OP                : 52
PLUS                 : 23
QUESTION             : 54
RND_PAR_CLOSE        : 55
RND_PAR_OPEN         : 55
SEMICOLON            : 6 59
STRING               : 15
STRING_LITERAL       : 19
VOID                 : 11
WHILE                : 58 59
error                : 

Nonterminals, with rules where they appear

additive_expression  : 23 24 25 26 27
and_expression       : 50 51 52
assignment_expression : 8 54
compound_statement   : 30 31 31 55 56 57 58 59
conditional_expression : 30 31 54 58 59
declaration          : 1 2 32
declarator           : 7 8
equality_expression  : 47 48 49 50
function_definition  : 3
identifier_list      : 40 55
init_declarator      : 6
iteration_statement  : 4 33
literal              : 21
multiplicative_expression : 26 27 28 29 41 42 43 44 45
or_expression        : 52 53 54
primary_expression   : 22 23 24 29 56 56 57 57
program              : 2 0
relational_expression : 42 43 44 45 46 47 48
selection_statement  : 5 34
statement            : 35 36
statement_list       : 36 38
type_specifier       : 9 10 55

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declaration
    (2) program -> . program declaration
    (3) program -> . function_definition
    (4) program -> . iteration_statement
    (5) program -> . selection_statement
    (6) declaration -> . init_declarator SEMICOLON
    (55) function_definition -> . FUNC IDENTIFIER RND_PAR_OPEN identifier_list RND_PAR_CLOSE ARROW type_specifier compound_statement
    (56) iteration_statement -> . FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON INC_OP compound_statement
    (57) iteration_statement -> . FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON DEC_OP compound_statement
    (58) iteration_statement -> . WHILE conditional_expression compound_statement
    (59) iteration_statement -> . DO compound_statement WHILE conditional_expression SEMICOLON
    (30) selection_statement -> . IF conditional_expression compound_statement
    (31) selection_statement -> . IF conditional_expression compound_statement ELSE compound_statement
    (7) init_declarator -> . declarator
    (8) init_declarator -> . declarator EQUALS assignment_expression
    (9) declarator -> . LET IDENTIFIER COLON type_specifier
    (10) declarator -> . CONST IDENTIFIER COLON type_specifier

    FUNC            shift and go to state 7
    FROM            shift and go to state 8
    WHILE           shift and go to state 9
    DO              shift and go to state 10
    IF              shift and go to state 11
    LET             shift and go to state 13
    CONST           shift and go to state 14

    program                        shift and go to state 1
    declaration                    shift and go to state 2
    function_definition            shift and go to state 3
    iteration_statement            shift and go to state 4
    selection_statement            shift and go to state 5
    init_declarator                shift and go to state 6
    declarator                     shift and go to state 12

state 1

    (0) S' -> program .
    (2) program -> program . declaration
    (6) declaration -> . init_declarator SEMICOLON
    (7) init_declarator -> . declarator
    (8) init_declarator -> . declarator EQUALS assignment_expression
    (9) declarator -> . LET IDENTIFIER COLON type_specifier
    (10) declarator -> . CONST IDENTIFIER COLON type_specifier

    LET             shift and go to state 13
    CONST           shift and go to state 14

    declaration                    shift and go to state 15
    init_declarator                shift and go to state 6
    declarator                     shift and go to state 12

state 2

    (1) program -> declaration .

    LET             reduce using rule 1 (program -> declaration .)
    CONST           reduce using rule 1 (program -> declaration .)
    $end            reduce using rule 1 (program -> declaration .)


state 3

    (3) program -> function_definition .

    LET             reduce using rule 3 (program -> function_definition .)
    CONST           reduce using rule 3 (program -> function_definition .)
    $end            reduce using rule 3 (program -> function_definition .)


state 4

    (4) program -> iteration_statement .

    LET             reduce using rule 4 (program -> iteration_statement .)
    CONST           reduce using rule 4 (program -> iteration_statement .)
    $end            reduce using rule 4 (program -> iteration_statement .)


state 5

    (5) program -> selection_statement .

    LET             reduce using rule 5 (program -> selection_statement .)
    CONST           reduce using rule 5 (program -> selection_statement .)
    $end            reduce using rule 5 (program -> selection_statement .)


state 6

    (6) declaration -> init_declarator . SEMICOLON

    SEMICOLON       shift and go to state 16


state 7

    (55) function_definition -> FUNC . IDENTIFIER RND_PAR_OPEN identifier_list RND_PAR_CLOSE ARROW type_specifier compound_statement

    IDENTIFIER      shift and go to state 17


state 8

    (56) iteration_statement -> FROM . BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON INC_OP compound_statement
    (57) iteration_statement -> FROM . BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON DEC_OP compound_statement

    BOX_PAR_OPEN    shift and go to state 18


state 9

    (58) iteration_statement -> WHILE . conditional_expression compound_statement
    (53) conditional_expression -> . or_expression
    (54) conditional_expression -> . or_expression QUESTION assignment_expression COLON conditional_expression
    (51) or_expression -> . and_expression
    (52) or_expression -> . or_expression OR_OP and_expression
    (49) and_expression -> . equality_expression
    (50) and_expression -> . and_expression AND_OP equality_expression
    (46) equality_expression -> . relational_expression
    (47) equality_expression -> . equality_expression EQ_OP relational_expression
    (48) equality_expression -> . equality_expression NE_OP relational_expression
    (41) relational_expression -> . multiplicative_expression
    (42) relational_expression -> . relational_expression LESS_OP multiplicative_expression
    (43) relational_expression -> . relational_expression GREATER_OP multiplicative_expression
    (44) relational_expression -> . relational_expression LE_OP multiplicative_expression
    (45) relational_expression -> . relational_expression GE_OP multiplicative_expression
    (25) multiplicative_expression -> . additive_expression
    (26) multiplicative_expression -> . multiplicative_expression MUL additive_expression
    (27) multiplicative_expression -> . multiplicative_expression DIV additive_expression
    (22) additive_expression -> . primary_expression
    (23) additive_expression -> . additive_expression PLUS primary_expression
    (24) additive_expression -> . additive_expression MINUS primary_expression
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    conditional_expression         shift and go to state 19
    or_expression                  shift and go to state 20
    and_expression                 shift and go to state 21
    equality_expression            shift and go to state 22
    relational_expression          shift and go to state 23
    multiplicative_expression      shift and go to state 24
    additive_expression            shift and go to state 25
    primary_expression             shift and go to state 26
    literal                        shift and go to state 28

state 10

    (59) iteration_statement -> DO . compound_statement WHILE conditional_expression SEMICOLON
    (37) compound_statement -> . CUR_PAR_OPEN CUR_PAR_CLOSE
    (38) compound_statement -> . CUR_PAR_OPEN statement_list CUR_PAR_CLOSE

    CUR_PAR_OPEN    shift and go to state 33

    compound_statement             shift and go to state 32

state 11

    (30) selection_statement -> IF . conditional_expression compound_statement
    (31) selection_statement -> IF . conditional_expression compound_statement ELSE compound_statement
    (53) conditional_expression -> . or_expression
    (54) conditional_expression -> . or_expression QUESTION assignment_expression COLON conditional_expression
    (51) or_expression -> . and_expression
    (52) or_expression -> . or_expression OR_OP and_expression
    (49) and_expression -> . equality_expression
    (50) and_expression -> . and_expression AND_OP equality_expression
    (46) equality_expression -> . relational_expression
    (47) equality_expression -> . equality_expression EQ_OP relational_expression
    (48) equality_expression -> . equality_expression NE_OP relational_expression
    (41) relational_expression -> . multiplicative_expression
    (42) relational_expression -> . relational_expression LESS_OP multiplicative_expression
    (43) relational_expression -> . relational_expression GREATER_OP multiplicative_expression
    (44) relational_expression -> . relational_expression LE_OP multiplicative_expression
    (45) relational_expression -> . relational_expression GE_OP multiplicative_expression
    (25) multiplicative_expression -> . additive_expression
    (26) multiplicative_expression -> . multiplicative_expression MUL additive_expression
    (27) multiplicative_expression -> . multiplicative_expression DIV additive_expression
    (22) additive_expression -> . primary_expression
    (23) additive_expression -> . additive_expression PLUS primary_expression
    (24) additive_expression -> . additive_expression MINUS primary_expression
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    conditional_expression         shift and go to state 34
    or_expression                  shift and go to state 20
    and_expression                 shift and go to state 21
    equality_expression            shift and go to state 22
    relational_expression          shift and go to state 23
    multiplicative_expression      shift and go to state 24
    additive_expression            shift and go to state 25
    primary_expression             shift and go to state 26
    literal                        shift and go to state 28

state 12

    (7) init_declarator -> declarator .
    (8) init_declarator -> declarator . EQUALS assignment_expression

    SEMICOLON       reduce using rule 7 (init_declarator -> declarator .)
    EQUALS          shift and go to state 35


state 13

    (9) declarator -> LET . IDENTIFIER COLON type_specifier

    IDENTIFIER      shift and go to state 36


state 14

    (10) declarator -> CONST . IDENTIFIER COLON type_specifier

    IDENTIFIER      shift and go to state 37


state 15

    (2) program -> program declaration .

    LET             reduce using rule 2 (program -> program declaration .)
    CONST           reduce using rule 2 (program -> program declaration .)
    $end            reduce using rule 2 (program -> program declaration .)


state 16

    (6) declaration -> init_declarator SEMICOLON .

    LET             reduce using rule 6 (declaration -> init_declarator SEMICOLON .)
    CONST           reduce using rule 6 (declaration -> init_declarator SEMICOLON .)
    $end            reduce using rule 6 (declaration -> init_declarator SEMICOLON .)
    CUR_PAR_CLOSE   reduce using rule 6 (declaration -> init_declarator SEMICOLON .)
    FROM            reduce using rule 6 (declaration -> init_declarator SEMICOLON .)
    WHILE           reduce using rule 6 (declaration -> init_declarator SEMICOLON .)
    DO              reduce using rule 6 (declaration -> init_declarator SEMICOLON .)
    IF              reduce using rule 6 (declaration -> init_declarator SEMICOLON .)


state 17

    (55) function_definition -> FUNC IDENTIFIER . RND_PAR_OPEN identifier_list RND_PAR_CLOSE ARROW type_specifier compound_statement

    RND_PAR_OPEN    shift and go to state 38


state 18

    (56) iteration_statement -> FROM BOX_PAR_OPEN . primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON INC_OP compound_statement
    (57) iteration_statement -> FROM BOX_PAR_OPEN . primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON DEC_OP compound_statement
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    primary_expression             shift and go to state 39
    literal                        shift and go to state 28

state 19

    (58) iteration_statement -> WHILE conditional_expression . compound_statement
    (37) compound_statement -> . CUR_PAR_OPEN CUR_PAR_CLOSE
    (38) compound_statement -> . CUR_PAR_OPEN statement_list CUR_PAR_CLOSE

    CUR_PAR_OPEN    shift and go to state 33

    compound_statement             shift and go to state 40

state 20

    (53) conditional_expression -> or_expression .
    (54) conditional_expression -> or_expression . QUESTION assignment_expression COLON conditional_expression
    (52) or_expression -> or_expression . OR_OP and_expression

    CUR_PAR_OPEN    reduce using rule 53 (conditional_expression -> or_expression .)
    SEMICOLON       reduce using rule 53 (conditional_expression -> or_expression .)
    QUESTION        shift and go to state 41
    OR_OP           shift and go to state 42


state 21

    (51) or_expression -> and_expression .
    (50) and_expression -> and_expression . AND_OP equality_expression

    QUESTION        reduce using rule 51 (or_expression -> and_expression .)
    OR_OP           reduce using rule 51 (or_expression -> and_expression .)
    CUR_PAR_OPEN    reduce using rule 51 (or_expression -> and_expression .)
    SEMICOLON       reduce using rule 51 (or_expression -> and_expression .)
    AND_OP          shift and go to state 43


state 22

    (49) and_expression -> equality_expression .
    (47) equality_expression -> equality_expression . EQ_OP relational_expression
    (48) equality_expression -> equality_expression . NE_OP relational_expression

    AND_OP          reduce using rule 49 (and_expression -> equality_expression .)
    QUESTION        reduce using rule 49 (and_expression -> equality_expression .)
    OR_OP           reduce using rule 49 (and_expression -> equality_expression .)
    CUR_PAR_OPEN    reduce using rule 49 (and_expression -> equality_expression .)
    SEMICOLON       reduce using rule 49 (and_expression -> equality_expression .)
    EQ_OP           shift and go to state 44
    NE_OP           shift and go to state 45


state 23

    (46) equality_expression -> relational_expression .
    (42) relational_expression -> relational_expression . LESS_OP multiplicative_expression
    (43) relational_expression -> relational_expression . GREATER_OP multiplicative_expression
    (44) relational_expression -> relational_expression . LE_OP multiplicative_expression
    (45) relational_expression -> relational_expression . GE_OP multiplicative_expression

    EQ_OP           reduce using rule 46 (equality_expression -> relational_expression .)
    NE_OP           reduce using rule 46 (equality_expression -> relational_expression .)
    AND_OP          reduce using rule 46 (equality_expression -> relational_expression .)
    QUESTION        reduce using rule 46 (equality_expression -> relational_expression .)
    OR_OP           reduce using rule 46 (equality_expression -> relational_expression .)
    CUR_PAR_OPEN    reduce using rule 46 (equality_expression -> relational_expression .)
    SEMICOLON       reduce using rule 46 (equality_expression -> relational_expression .)
    LESS_OP         shift and go to state 46
    GREATER_OP      shift and go to state 47
    LE_OP           shift and go to state 48
    GE_OP           shift and go to state 49


state 24

    (41) relational_expression -> multiplicative_expression .
    (26) multiplicative_expression -> multiplicative_expression . MUL additive_expression
    (27) multiplicative_expression -> multiplicative_expression . DIV additive_expression

    LESS_OP         reduce using rule 41 (relational_expression -> multiplicative_expression .)
    GREATER_OP      reduce using rule 41 (relational_expression -> multiplicative_expression .)
    LE_OP           reduce using rule 41 (relational_expression -> multiplicative_expression .)
    GE_OP           reduce using rule 41 (relational_expression -> multiplicative_expression .)
    EQ_OP           reduce using rule 41 (relational_expression -> multiplicative_expression .)
    NE_OP           reduce using rule 41 (relational_expression -> multiplicative_expression .)
    AND_OP          reduce using rule 41 (relational_expression -> multiplicative_expression .)
    QUESTION        reduce using rule 41 (relational_expression -> multiplicative_expression .)
    OR_OP           reduce using rule 41 (relational_expression -> multiplicative_expression .)
    CUR_PAR_OPEN    reduce using rule 41 (relational_expression -> multiplicative_expression .)
    SEMICOLON       reduce using rule 41 (relational_expression -> multiplicative_expression .)
    MUL             shift and go to state 50
    DIV             shift and go to state 51


state 25

    (25) multiplicative_expression -> additive_expression .
    (23) additive_expression -> additive_expression . PLUS primary_expression
    (24) additive_expression -> additive_expression . MINUS primary_expression

    MUL             reduce using rule 25 (multiplicative_expression -> additive_expression .)
    DIV             reduce using rule 25 (multiplicative_expression -> additive_expression .)
    LESS_OP         reduce using rule 25 (multiplicative_expression -> additive_expression .)
    GREATER_OP      reduce using rule 25 (multiplicative_expression -> additive_expression .)
    LE_OP           reduce using rule 25 (multiplicative_expression -> additive_expression .)
    GE_OP           reduce using rule 25 (multiplicative_expression -> additive_expression .)
    EQ_OP           reduce using rule 25 (multiplicative_expression -> additive_expression .)
    NE_OP           reduce using rule 25 (multiplicative_expression -> additive_expression .)
    AND_OP          reduce using rule 25 (multiplicative_expression -> additive_expression .)
    QUESTION        reduce using rule 25 (multiplicative_expression -> additive_expression .)
    OR_OP           reduce using rule 25 (multiplicative_expression -> additive_expression .)
    CUR_PAR_OPEN    reduce using rule 25 (multiplicative_expression -> additive_expression .)
    SEMICOLON       reduce using rule 25 (multiplicative_expression -> additive_expression .)
    COLON           reduce using rule 25 (multiplicative_expression -> additive_expression .)
    PLUS            shift and go to state 52
    MINUS           shift and go to state 53


state 26

    (22) additive_expression -> primary_expression .

    PLUS            reduce using rule 22 (additive_expression -> primary_expression .)
    MINUS           reduce using rule 22 (additive_expression -> primary_expression .)
    MUL             reduce using rule 22 (additive_expression -> primary_expression .)
    DIV             reduce using rule 22 (additive_expression -> primary_expression .)
    LESS_OP         reduce using rule 22 (additive_expression -> primary_expression .)
    GREATER_OP      reduce using rule 22 (additive_expression -> primary_expression .)
    LE_OP           reduce using rule 22 (additive_expression -> primary_expression .)
    GE_OP           reduce using rule 22 (additive_expression -> primary_expression .)
    EQ_OP           reduce using rule 22 (additive_expression -> primary_expression .)
    NE_OP           reduce using rule 22 (additive_expression -> primary_expression .)
    AND_OP          reduce using rule 22 (additive_expression -> primary_expression .)
    QUESTION        reduce using rule 22 (additive_expression -> primary_expression .)
    OR_OP           reduce using rule 22 (additive_expression -> primary_expression .)
    CUR_PAR_OPEN    reduce using rule 22 (additive_expression -> primary_expression .)
    SEMICOLON       reduce using rule 22 (additive_expression -> primary_expression .)
    COLON           reduce using rule 22 (additive_expression -> primary_expression .)


state 27

    (20) primary_expression -> IDENTIFIER .

    PLUS            reduce using rule 20 (primary_expression -> IDENTIFIER .)
    MINUS           reduce using rule 20 (primary_expression -> IDENTIFIER .)
    MUL             reduce using rule 20 (primary_expression -> IDENTIFIER .)
    DIV             reduce using rule 20 (primary_expression -> IDENTIFIER .)
    LESS_OP         reduce using rule 20 (primary_expression -> IDENTIFIER .)
    GREATER_OP      reduce using rule 20 (primary_expression -> IDENTIFIER .)
    LE_OP           reduce using rule 20 (primary_expression -> IDENTIFIER .)
    GE_OP           reduce using rule 20 (primary_expression -> IDENTIFIER .)
    EQ_OP           reduce using rule 20 (primary_expression -> IDENTIFIER .)
    NE_OP           reduce using rule 20 (primary_expression -> IDENTIFIER .)
    AND_OP          reduce using rule 20 (primary_expression -> IDENTIFIER .)
    QUESTION        reduce using rule 20 (primary_expression -> IDENTIFIER .)
    OR_OP           reduce using rule 20 (primary_expression -> IDENTIFIER .)
    CUR_PAR_OPEN    reduce using rule 20 (primary_expression -> IDENTIFIER .)
    COMMA           reduce using rule 20 (primary_expression -> IDENTIFIER .)
    EQUALS          reduce using rule 20 (primary_expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 20 (primary_expression -> IDENTIFIER .)
    COLON           reduce using rule 20 (primary_expression -> IDENTIFIER .)
    BOX_PAR_CLOSE   reduce using rule 20 (primary_expression -> IDENTIFIER .)


state 28

    (21) primary_expression -> literal .

    PLUS            reduce using rule 21 (primary_expression -> literal .)
    MINUS           reduce using rule 21 (primary_expression -> literal .)
    MUL             reduce using rule 21 (primary_expression -> literal .)
    DIV             reduce using rule 21 (primary_expression -> literal .)
    LESS_OP         reduce using rule 21 (primary_expression -> literal .)
    GREATER_OP      reduce using rule 21 (primary_expression -> literal .)
    LE_OP           reduce using rule 21 (primary_expression -> literal .)
    GE_OP           reduce using rule 21 (primary_expression -> literal .)
    EQ_OP           reduce using rule 21 (primary_expression -> literal .)
    NE_OP           reduce using rule 21 (primary_expression -> literal .)
    AND_OP          reduce using rule 21 (primary_expression -> literal .)
    QUESTION        reduce using rule 21 (primary_expression -> literal .)
    OR_OP           reduce using rule 21 (primary_expression -> literal .)
    CUR_PAR_OPEN    reduce using rule 21 (primary_expression -> literal .)
    COMMA           reduce using rule 21 (primary_expression -> literal .)
    EQUALS          reduce using rule 21 (primary_expression -> literal .)
    SEMICOLON       reduce using rule 21 (primary_expression -> literal .)
    COLON           reduce using rule 21 (primary_expression -> literal .)
    BOX_PAR_CLOSE   reduce using rule 21 (primary_expression -> literal .)


state 29

    (17) literal -> INT_LITERAL .

    PLUS            reduce using rule 17 (literal -> INT_LITERAL .)
    MINUS           reduce using rule 17 (literal -> INT_LITERAL .)
    MUL             reduce using rule 17 (literal -> INT_LITERAL .)
    DIV             reduce using rule 17 (literal -> INT_LITERAL .)
    LESS_OP         reduce using rule 17 (literal -> INT_LITERAL .)
    GREATER_OP      reduce using rule 17 (literal -> INT_LITERAL .)
    LE_OP           reduce using rule 17 (literal -> INT_LITERAL .)
    GE_OP           reduce using rule 17 (literal -> INT_LITERAL .)
    EQ_OP           reduce using rule 17 (literal -> INT_LITERAL .)
    NE_OP           reduce using rule 17 (literal -> INT_LITERAL .)
    AND_OP          reduce using rule 17 (literal -> INT_LITERAL .)
    QUESTION        reduce using rule 17 (literal -> INT_LITERAL .)
    OR_OP           reduce using rule 17 (literal -> INT_LITERAL .)
    CUR_PAR_OPEN    reduce using rule 17 (literal -> INT_LITERAL .)
    COMMA           reduce using rule 17 (literal -> INT_LITERAL .)
    EQUALS          reduce using rule 17 (literal -> INT_LITERAL .)
    SEMICOLON       reduce using rule 17 (literal -> INT_LITERAL .)
    COLON           reduce using rule 17 (literal -> INT_LITERAL .)
    BOX_PAR_CLOSE   reduce using rule 17 (literal -> INT_LITERAL .)


state 30

    (18) literal -> FLOAT_LITERAL .

    PLUS            reduce using rule 18 (literal -> FLOAT_LITERAL .)
    MINUS           reduce using rule 18 (literal -> FLOAT_LITERAL .)
    MUL             reduce using rule 18 (literal -> FLOAT_LITERAL .)
    DIV             reduce using rule 18 (literal -> FLOAT_LITERAL .)
    LESS_OP         reduce using rule 18 (literal -> FLOAT_LITERAL .)
    GREATER_OP      reduce using rule 18 (literal -> FLOAT_LITERAL .)
    LE_OP           reduce using rule 18 (literal -> FLOAT_LITERAL .)
    GE_OP           reduce using rule 18 (literal -> FLOAT_LITERAL .)
    EQ_OP           reduce using rule 18 (literal -> FLOAT_LITERAL .)
    NE_OP           reduce using rule 18 (literal -> FLOAT_LITERAL .)
    AND_OP          reduce using rule 18 (literal -> FLOAT_LITERAL .)
    QUESTION        reduce using rule 18 (literal -> FLOAT_LITERAL .)
    OR_OP           reduce using rule 18 (literal -> FLOAT_LITERAL .)
    CUR_PAR_OPEN    reduce using rule 18 (literal -> FLOAT_LITERAL .)
    COMMA           reduce using rule 18 (literal -> FLOAT_LITERAL .)
    EQUALS          reduce using rule 18 (literal -> FLOAT_LITERAL .)
    SEMICOLON       reduce using rule 18 (literal -> FLOAT_LITERAL .)
    COLON           reduce using rule 18 (literal -> FLOAT_LITERAL .)
    BOX_PAR_CLOSE   reduce using rule 18 (literal -> FLOAT_LITERAL .)


state 31

    (19) literal -> STRING_LITERAL .

    PLUS            reduce using rule 19 (literal -> STRING_LITERAL .)
    MINUS           reduce using rule 19 (literal -> STRING_LITERAL .)
    MUL             reduce using rule 19 (literal -> STRING_LITERAL .)
    DIV             reduce using rule 19 (literal -> STRING_LITERAL .)
    LESS_OP         reduce using rule 19 (literal -> STRING_LITERAL .)
    GREATER_OP      reduce using rule 19 (literal -> STRING_LITERAL .)
    LE_OP           reduce using rule 19 (literal -> STRING_LITERAL .)
    GE_OP           reduce using rule 19 (literal -> STRING_LITERAL .)
    EQ_OP           reduce using rule 19 (literal -> STRING_LITERAL .)
    NE_OP           reduce using rule 19 (literal -> STRING_LITERAL .)
    AND_OP          reduce using rule 19 (literal -> STRING_LITERAL .)
    QUESTION        reduce using rule 19 (literal -> STRING_LITERAL .)
    OR_OP           reduce using rule 19 (literal -> STRING_LITERAL .)
    CUR_PAR_OPEN    reduce using rule 19 (literal -> STRING_LITERAL .)
    COMMA           reduce using rule 19 (literal -> STRING_LITERAL .)
    EQUALS          reduce using rule 19 (literal -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 19 (literal -> STRING_LITERAL .)
    COLON           reduce using rule 19 (literal -> STRING_LITERAL .)
    BOX_PAR_CLOSE   reduce using rule 19 (literal -> STRING_LITERAL .)


state 32

    (59) iteration_statement -> DO compound_statement . WHILE conditional_expression SEMICOLON

    WHILE           shift and go to state 54


state 33

    (37) compound_statement -> CUR_PAR_OPEN . CUR_PAR_CLOSE
    (38) compound_statement -> CUR_PAR_OPEN . statement_list CUR_PAR_CLOSE
    (35) statement_list -> . statement
    (36) statement_list -> . statement_list statement
    (32) statement -> . declaration
    (33) statement -> . iteration_statement
    (34) statement -> . selection_statement
    (6) declaration -> . init_declarator SEMICOLON
    (56) iteration_statement -> . FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON INC_OP compound_statement
    (57) iteration_statement -> . FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON DEC_OP compound_statement
    (58) iteration_statement -> . WHILE conditional_expression compound_statement
    (59) iteration_statement -> . DO compound_statement WHILE conditional_expression SEMICOLON
    (30) selection_statement -> . IF conditional_expression compound_statement
    (31) selection_statement -> . IF conditional_expression compound_statement ELSE compound_statement
    (7) init_declarator -> . declarator
    (8) init_declarator -> . declarator EQUALS assignment_expression
    (9) declarator -> . LET IDENTIFIER COLON type_specifier
    (10) declarator -> . CONST IDENTIFIER COLON type_specifier

    CUR_PAR_CLOSE   shift and go to state 55
    FROM            shift and go to state 8
    WHILE           shift and go to state 9
    DO              shift and go to state 10
    IF              shift and go to state 11
    LET             shift and go to state 13
    CONST           shift and go to state 14

    statement_list                 shift and go to state 56
    statement                      shift and go to state 57
    declaration                    shift and go to state 58
    iteration_statement            shift and go to state 59
    selection_statement            shift and go to state 60
    init_declarator                shift and go to state 6
    declarator                     shift and go to state 12

state 34

    (30) selection_statement -> IF conditional_expression . compound_statement
    (31) selection_statement -> IF conditional_expression . compound_statement ELSE compound_statement
    (37) compound_statement -> . CUR_PAR_OPEN CUR_PAR_CLOSE
    (38) compound_statement -> . CUR_PAR_OPEN statement_list CUR_PAR_CLOSE

    CUR_PAR_OPEN    shift and go to state 33

    compound_statement             shift and go to state 61

state 35

    (8) init_declarator -> declarator EQUALS . assignment_expression
    (28) assignment_expression -> . multiplicative_expression
    (29) assignment_expression -> . primary_expression EQUALS multiplicative_expression
    (25) multiplicative_expression -> . additive_expression
    (26) multiplicative_expression -> . multiplicative_expression MUL additive_expression
    (27) multiplicative_expression -> . multiplicative_expression DIV additive_expression
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (22) additive_expression -> . primary_expression
    (23) additive_expression -> . additive_expression PLUS primary_expression
    (24) additive_expression -> . additive_expression MINUS primary_expression
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    assignment_expression          shift and go to state 62
    multiplicative_expression      shift and go to state 63
    primary_expression             shift and go to state 64
    additive_expression            shift and go to state 25
    literal                        shift and go to state 28

state 36

    (9) declarator -> LET IDENTIFIER . COLON type_specifier

    COLON           shift and go to state 65


state 37

    (10) declarator -> CONST IDENTIFIER . COLON type_specifier

    COLON           shift and go to state 66


state 38

    (55) function_definition -> FUNC IDENTIFIER RND_PAR_OPEN . identifier_list RND_PAR_CLOSE ARROW type_specifier compound_statement
    (39) identifier_list -> . IDENTIFIER
    (40) identifier_list -> . identifier_list COMMA IDENTIFIER

    IDENTIFIER      shift and go to state 67

    identifier_list                shift and go to state 68

state 39

    (56) iteration_statement -> FROM BOX_PAR_OPEN primary_expression . COMMA primary_expression BOX_PAR_CLOSE COLON INC_OP compound_statement
    (57) iteration_statement -> FROM BOX_PAR_OPEN primary_expression . COMMA primary_expression BOX_PAR_CLOSE COLON DEC_OP compound_statement

    COMMA           shift and go to state 69


state 40

    (58) iteration_statement -> WHILE conditional_expression compound_statement .

    LET             reduce using rule 58 (iteration_statement -> WHILE conditional_expression compound_statement .)
    CONST           reduce using rule 58 (iteration_statement -> WHILE conditional_expression compound_statement .)
    $end            reduce using rule 58 (iteration_statement -> WHILE conditional_expression compound_statement .)
    CUR_PAR_CLOSE   reduce using rule 58 (iteration_statement -> WHILE conditional_expression compound_statement .)
    FROM            reduce using rule 58 (iteration_statement -> WHILE conditional_expression compound_statement .)
    WHILE           reduce using rule 58 (iteration_statement -> WHILE conditional_expression compound_statement .)
    DO              reduce using rule 58 (iteration_statement -> WHILE conditional_expression compound_statement .)
    IF              reduce using rule 58 (iteration_statement -> WHILE conditional_expression compound_statement .)


state 41

    (54) conditional_expression -> or_expression QUESTION . assignment_expression COLON conditional_expression
    (28) assignment_expression -> . multiplicative_expression
    (29) assignment_expression -> . primary_expression EQUALS multiplicative_expression
    (25) multiplicative_expression -> . additive_expression
    (26) multiplicative_expression -> . multiplicative_expression MUL additive_expression
    (27) multiplicative_expression -> . multiplicative_expression DIV additive_expression
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (22) additive_expression -> . primary_expression
    (23) additive_expression -> . additive_expression PLUS primary_expression
    (24) additive_expression -> . additive_expression MINUS primary_expression
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    assignment_expression          shift and go to state 70
    multiplicative_expression      shift and go to state 63
    primary_expression             shift and go to state 64
    additive_expression            shift and go to state 25
    literal                        shift and go to state 28

state 42

    (52) or_expression -> or_expression OR_OP . and_expression
    (49) and_expression -> . equality_expression
    (50) and_expression -> . and_expression AND_OP equality_expression
    (46) equality_expression -> . relational_expression
    (47) equality_expression -> . equality_expression EQ_OP relational_expression
    (48) equality_expression -> . equality_expression NE_OP relational_expression
    (41) relational_expression -> . multiplicative_expression
    (42) relational_expression -> . relational_expression LESS_OP multiplicative_expression
    (43) relational_expression -> . relational_expression GREATER_OP multiplicative_expression
    (44) relational_expression -> . relational_expression LE_OP multiplicative_expression
    (45) relational_expression -> . relational_expression GE_OP multiplicative_expression
    (25) multiplicative_expression -> . additive_expression
    (26) multiplicative_expression -> . multiplicative_expression MUL additive_expression
    (27) multiplicative_expression -> . multiplicative_expression DIV additive_expression
    (22) additive_expression -> . primary_expression
    (23) additive_expression -> . additive_expression PLUS primary_expression
    (24) additive_expression -> . additive_expression MINUS primary_expression
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    and_expression                 shift and go to state 71
    equality_expression            shift and go to state 22
    relational_expression          shift and go to state 23
    multiplicative_expression      shift and go to state 24
    additive_expression            shift and go to state 25
    primary_expression             shift and go to state 26
    literal                        shift and go to state 28

state 43

    (50) and_expression -> and_expression AND_OP . equality_expression
    (46) equality_expression -> . relational_expression
    (47) equality_expression -> . equality_expression EQ_OP relational_expression
    (48) equality_expression -> . equality_expression NE_OP relational_expression
    (41) relational_expression -> . multiplicative_expression
    (42) relational_expression -> . relational_expression LESS_OP multiplicative_expression
    (43) relational_expression -> . relational_expression GREATER_OP multiplicative_expression
    (44) relational_expression -> . relational_expression LE_OP multiplicative_expression
    (45) relational_expression -> . relational_expression GE_OP multiplicative_expression
    (25) multiplicative_expression -> . additive_expression
    (26) multiplicative_expression -> . multiplicative_expression MUL additive_expression
    (27) multiplicative_expression -> . multiplicative_expression DIV additive_expression
    (22) additive_expression -> . primary_expression
    (23) additive_expression -> . additive_expression PLUS primary_expression
    (24) additive_expression -> . additive_expression MINUS primary_expression
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    equality_expression            shift and go to state 72
    relational_expression          shift and go to state 23
    multiplicative_expression      shift and go to state 24
    additive_expression            shift and go to state 25
    primary_expression             shift and go to state 26
    literal                        shift and go to state 28

state 44

    (47) equality_expression -> equality_expression EQ_OP . relational_expression
    (41) relational_expression -> . multiplicative_expression
    (42) relational_expression -> . relational_expression LESS_OP multiplicative_expression
    (43) relational_expression -> . relational_expression GREATER_OP multiplicative_expression
    (44) relational_expression -> . relational_expression LE_OP multiplicative_expression
    (45) relational_expression -> . relational_expression GE_OP multiplicative_expression
    (25) multiplicative_expression -> . additive_expression
    (26) multiplicative_expression -> . multiplicative_expression MUL additive_expression
    (27) multiplicative_expression -> . multiplicative_expression DIV additive_expression
    (22) additive_expression -> . primary_expression
    (23) additive_expression -> . additive_expression PLUS primary_expression
    (24) additive_expression -> . additive_expression MINUS primary_expression
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    relational_expression          shift and go to state 73
    multiplicative_expression      shift and go to state 24
    additive_expression            shift and go to state 25
    primary_expression             shift and go to state 26
    literal                        shift and go to state 28

state 45

    (48) equality_expression -> equality_expression NE_OP . relational_expression
    (41) relational_expression -> . multiplicative_expression
    (42) relational_expression -> . relational_expression LESS_OP multiplicative_expression
    (43) relational_expression -> . relational_expression GREATER_OP multiplicative_expression
    (44) relational_expression -> . relational_expression LE_OP multiplicative_expression
    (45) relational_expression -> . relational_expression GE_OP multiplicative_expression
    (25) multiplicative_expression -> . additive_expression
    (26) multiplicative_expression -> . multiplicative_expression MUL additive_expression
    (27) multiplicative_expression -> . multiplicative_expression DIV additive_expression
    (22) additive_expression -> . primary_expression
    (23) additive_expression -> . additive_expression PLUS primary_expression
    (24) additive_expression -> . additive_expression MINUS primary_expression
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    relational_expression          shift and go to state 74
    multiplicative_expression      shift and go to state 24
    additive_expression            shift and go to state 25
    primary_expression             shift and go to state 26
    literal                        shift and go to state 28

state 46

    (42) relational_expression -> relational_expression LESS_OP . multiplicative_expression
    (25) multiplicative_expression -> . additive_expression
    (26) multiplicative_expression -> . multiplicative_expression MUL additive_expression
    (27) multiplicative_expression -> . multiplicative_expression DIV additive_expression
    (22) additive_expression -> . primary_expression
    (23) additive_expression -> . additive_expression PLUS primary_expression
    (24) additive_expression -> . additive_expression MINUS primary_expression
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    multiplicative_expression      shift and go to state 75
    additive_expression            shift and go to state 25
    primary_expression             shift and go to state 26
    literal                        shift and go to state 28

state 47

    (43) relational_expression -> relational_expression GREATER_OP . multiplicative_expression
    (25) multiplicative_expression -> . additive_expression
    (26) multiplicative_expression -> . multiplicative_expression MUL additive_expression
    (27) multiplicative_expression -> . multiplicative_expression DIV additive_expression
    (22) additive_expression -> . primary_expression
    (23) additive_expression -> . additive_expression PLUS primary_expression
    (24) additive_expression -> . additive_expression MINUS primary_expression
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    multiplicative_expression      shift and go to state 76
    additive_expression            shift and go to state 25
    primary_expression             shift and go to state 26
    literal                        shift and go to state 28

state 48

    (44) relational_expression -> relational_expression LE_OP . multiplicative_expression
    (25) multiplicative_expression -> . additive_expression
    (26) multiplicative_expression -> . multiplicative_expression MUL additive_expression
    (27) multiplicative_expression -> . multiplicative_expression DIV additive_expression
    (22) additive_expression -> . primary_expression
    (23) additive_expression -> . additive_expression PLUS primary_expression
    (24) additive_expression -> . additive_expression MINUS primary_expression
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    multiplicative_expression      shift and go to state 77
    additive_expression            shift and go to state 25
    primary_expression             shift and go to state 26
    literal                        shift and go to state 28

state 49

    (45) relational_expression -> relational_expression GE_OP . multiplicative_expression
    (25) multiplicative_expression -> . additive_expression
    (26) multiplicative_expression -> . multiplicative_expression MUL additive_expression
    (27) multiplicative_expression -> . multiplicative_expression DIV additive_expression
    (22) additive_expression -> . primary_expression
    (23) additive_expression -> . additive_expression PLUS primary_expression
    (24) additive_expression -> . additive_expression MINUS primary_expression
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    multiplicative_expression      shift and go to state 78
    additive_expression            shift and go to state 25
    primary_expression             shift and go to state 26
    literal                        shift and go to state 28

state 50

    (26) multiplicative_expression -> multiplicative_expression MUL . additive_expression
    (22) additive_expression -> . primary_expression
    (23) additive_expression -> . additive_expression PLUS primary_expression
    (24) additive_expression -> . additive_expression MINUS primary_expression
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    additive_expression            shift and go to state 79
    primary_expression             shift and go to state 26
    literal                        shift and go to state 28

state 51

    (27) multiplicative_expression -> multiplicative_expression DIV . additive_expression
    (22) additive_expression -> . primary_expression
    (23) additive_expression -> . additive_expression PLUS primary_expression
    (24) additive_expression -> . additive_expression MINUS primary_expression
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    additive_expression            shift and go to state 80
    primary_expression             shift and go to state 26
    literal                        shift and go to state 28

state 52

    (23) additive_expression -> additive_expression PLUS . primary_expression
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    primary_expression             shift and go to state 81
    literal                        shift and go to state 28

state 53

    (24) additive_expression -> additive_expression MINUS . primary_expression
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    primary_expression             shift and go to state 82
    literal                        shift and go to state 28

state 54

    (59) iteration_statement -> DO compound_statement WHILE . conditional_expression SEMICOLON
    (53) conditional_expression -> . or_expression
    (54) conditional_expression -> . or_expression QUESTION assignment_expression COLON conditional_expression
    (51) or_expression -> . and_expression
    (52) or_expression -> . or_expression OR_OP and_expression
    (49) and_expression -> . equality_expression
    (50) and_expression -> . and_expression AND_OP equality_expression
    (46) equality_expression -> . relational_expression
    (47) equality_expression -> . equality_expression EQ_OP relational_expression
    (48) equality_expression -> . equality_expression NE_OP relational_expression
    (41) relational_expression -> . multiplicative_expression
    (42) relational_expression -> . relational_expression LESS_OP multiplicative_expression
    (43) relational_expression -> . relational_expression GREATER_OP multiplicative_expression
    (44) relational_expression -> . relational_expression LE_OP multiplicative_expression
    (45) relational_expression -> . relational_expression GE_OP multiplicative_expression
    (25) multiplicative_expression -> . additive_expression
    (26) multiplicative_expression -> . multiplicative_expression MUL additive_expression
    (27) multiplicative_expression -> . multiplicative_expression DIV additive_expression
    (22) additive_expression -> . primary_expression
    (23) additive_expression -> . additive_expression PLUS primary_expression
    (24) additive_expression -> . additive_expression MINUS primary_expression
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    conditional_expression         shift and go to state 83
    or_expression                  shift and go to state 20
    and_expression                 shift and go to state 21
    equality_expression            shift and go to state 22
    relational_expression          shift and go to state 23
    multiplicative_expression      shift and go to state 24
    additive_expression            shift and go to state 25
    primary_expression             shift and go to state 26
    literal                        shift and go to state 28

state 55

    (37) compound_statement -> CUR_PAR_OPEN CUR_PAR_CLOSE .

    WHILE           reduce using rule 37 (compound_statement -> CUR_PAR_OPEN CUR_PAR_CLOSE .)
    LET             reduce using rule 37 (compound_statement -> CUR_PAR_OPEN CUR_PAR_CLOSE .)
    CONST           reduce using rule 37 (compound_statement -> CUR_PAR_OPEN CUR_PAR_CLOSE .)
    $end            reduce using rule 37 (compound_statement -> CUR_PAR_OPEN CUR_PAR_CLOSE .)
    CUR_PAR_CLOSE   reduce using rule 37 (compound_statement -> CUR_PAR_OPEN CUR_PAR_CLOSE .)
    FROM            reduce using rule 37 (compound_statement -> CUR_PAR_OPEN CUR_PAR_CLOSE .)
    DO              reduce using rule 37 (compound_statement -> CUR_PAR_OPEN CUR_PAR_CLOSE .)
    IF              reduce using rule 37 (compound_statement -> CUR_PAR_OPEN CUR_PAR_CLOSE .)
    ELSE            reduce using rule 37 (compound_statement -> CUR_PAR_OPEN CUR_PAR_CLOSE .)


state 56

    (38) compound_statement -> CUR_PAR_OPEN statement_list . CUR_PAR_CLOSE
    (36) statement_list -> statement_list . statement
    (32) statement -> . declaration
    (33) statement -> . iteration_statement
    (34) statement -> . selection_statement
    (6) declaration -> . init_declarator SEMICOLON
    (56) iteration_statement -> . FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON INC_OP compound_statement
    (57) iteration_statement -> . FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON DEC_OP compound_statement
    (58) iteration_statement -> . WHILE conditional_expression compound_statement
    (59) iteration_statement -> . DO compound_statement WHILE conditional_expression SEMICOLON
    (30) selection_statement -> . IF conditional_expression compound_statement
    (31) selection_statement -> . IF conditional_expression compound_statement ELSE compound_statement
    (7) init_declarator -> . declarator
    (8) init_declarator -> . declarator EQUALS assignment_expression
    (9) declarator -> . LET IDENTIFIER COLON type_specifier
    (10) declarator -> . CONST IDENTIFIER COLON type_specifier

    CUR_PAR_CLOSE   shift and go to state 84
    FROM            shift and go to state 8
    WHILE           shift and go to state 9
    DO              shift and go to state 10
    IF              shift and go to state 11
    LET             shift and go to state 13
    CONST           shift and go to state 14

    statement                      shift and go to state 85
    declaration                    shift and go to state 58
    iteration_statement            shift and go to state 59
    selection_statement            shift and go to state 60
    init_declarator                shift and go to state 6
    declarator                     shift and go to state 12

state 57

    (35) statement_list -> statement .

    CUR_PAR_CLOSE   reduce using rule 35 (statement_list -> statement .)
    FROM            reduce using rule 35 (statement_list -> statement .)
    WHILE           reduce using rule 35 (statement_list -> statement .)
    DO              reduce using rule 35 (statement_list -> statement .)
    IF              reduce using rule 35 (statement_list -> statement .)
    LET             reduce using rule 35 (statement_list -> statement .)
    CONST           reduce using rule 35 (statement_list -> statement .)


state 58

    (32) statement -> declaration .

    CUR_PAR_CLOSE   reduce using rule 32 (statement -> declaration .)
    FROM            reduce using rule 32 (statement -> declaration .)
    WHILE           reduce using rule 32 (statement -> declaration .)
    DO              reduce using rule 32 (statement -> declaration .)
    IF              reduce using rule 32 (statement -> declaration .)
    LET             reduce using rule 32 (statement -> declaration .)
    CONST           reduce using rule 32 (statement -> declaration .)


state 59

    (33) statement -> iteration_statement .

    CUR_PAR_CLOSE   reduce using rule 33 (statement -> iteration_statement .)
    FROM            reduce using rule 33 (statement -> iteration_statement .)
    WHILE           reduce using rule 33 (statement -> iteration_statement .)
    DO              reduce using rule 33 (statement -> iteration_statement .)
    IF              reduce using rule 33 (statement -> iteration_statement .)
    LET             reduce using rule 33 (statement -> iteration_statement .)
    CONST           reduce using rule 33 (statement -> iteration_statement .)


state 60

    (34) statement -> selection_statement .

    CUR_PAR_CLOSE   reduce using rule 34 (statement -> selection_statement .)
    FROM            reduce using rule 34 (statement -> selection_statement .)
    WHILE           reduce using rule 34 (statement -> selection_statement .)
    DO              reduce using rule 34 (statement -> selection_statement .)
    IF              reduce using rule 34 (statement -> selection_statement .)
    LET             reduce using rule 34 (statement -> selection_statement .)
    CONST           reduce using rule 34 (statement -> selection_statement .)


state 61

    (30) selection_statement -> IF conditional_expression compound_statement .
    (31) selection_statement -> IF conditional_expression compound_statement . ELSE compound_statement

    LET             reduce using rule 30 (selection_statement -> IF conditional_expression compound_statement .)
    CONST           reduce using rule 30 (selection_statement -> IF conditional_expression compound_statement .)
    $end            reduce using rule 30 (selection_statement -> IF conditional_expression compound_statement .)
    CUR_PAR_CLOSE   reduce using rule 30 (selection_statement -> IF conditional_expression compound_statement .)
    FROM            reduce using rule 30 (selection_statement -> IF conditional_expression compound_statement .)
    WHILE           reduce using rule 30 (selection_statement -> IF conditional_expression compound_statement .)
    DO              reduce using rule 30 (selection_statement -> IF conditional_expression compound_statement .)
    IF              reduce using rule 30 (selection_statement -> IF conditional_expression compound_statement .)
    ELSE            shift and go to state 86


state 62

    (8) init_declarator -> declarator EQUALS assignment_expression .

    SEMICOLON       reduce using rule 8 (init_declarator -> declarator EQUALS assignment_expression .)


state 63

    (28) assignment_expression -> multiplicative_expression .
    (26) multiplicative_expression -> multiplicative_expression . MUL additive_expression
    (27) multiplicative_expression -> multiplicative_expression . DIV additive_expression

    SEMICOLON       reduce using rule 28 (assignment_expression -> multiplicative_expression .)
    COLON           reduce using rule 28 (assignment_expression -> multiplicative_expression .)
    MUL             shift and go to state 50
    DIV             shift and go to state 51


state 64

    (29) assignment_expression -> primary_expression . EQUALS multiplicative_expression
    (22) additive_expression -> primary_expression .

    EQUALS          shift and go to state 87
    PLUS            reduce using rule 22 (additive_expression -> primary_expression .)
    MINUS           reduce using rule 22 (additive_expression -> primary_expression .)
    MUL             reduce using rule 22 (additive_expression -> primary_expression .)
    DIV             reduce using rule 22 (additive_expression -> primary_expression .)
    SEMICOLON       reduce using rule 22 (additive_expression -> primary_expression .)
    COLON           reduce using rule 22 (additive_expression -> primary_expression .)


state 65

    (9) declarator -> LET IDENTIFIER COLON . type_specifier
    (11) type_specifier -> . VOID
    (12) type_specifier -> . CHAR
    (13) type_specifier -> . INT
    (14) type_specifier -> . FLOAT
    (15) type_specifier -> . STRING
    (16) type_specifier -> . BOOL

    VOID            shift and go to state 89
    CHAR            shift and go to state 90
    INT             shift and go to state 91
    FLOAT           shift and go to state 92
    STRING          shift and go to state 93
    BOOL            shift and go to state 94

    type_specifier                 shift and go to state 88

state 66

    (10) declarator -> CONST IDENTIFIER COLON . type_specifier
    (11) type_specifier -> . VOID
    (12) type_specifier -> . CHAR
    (13) type_specifier -> . INT
    (14) type_specifier -> . FLOAT
    (15) type_specifier -> . STRING
    (16) type_specifier -> . BOOL

    VOID            shift and go to state 89
    CHAR            shift and go to state 90
    INT             shift and go to state 91
    FLOAT           shift and go to state 92
    STRING          shift and go to state 93
    BOOL            shift and go to state 94

    type_specifier                 shift and go to state 95

state 67

    (39) identifier_list -> IDENTIFIER .

    RND_PAR_CLOSE   reduce using rule 39 (identifier_list -> IDENTIFIER .)
    COMMA           reduce using rule 39 (identifier_list -> IDENTIFIER .)


state 68

    (55) function_definition -> FUNC IDENTIFIER RND_PAR_OPEN identifier_list . RND_PAR_CLOSE ARROW type_specifier compound_statement
    (40) identifier_list -> identifier_list . COMMA IDENTIFIER

    RND_PAR_CLOSE   shift and go to state 96
    COMMA           shift and go to state 97


state 69

    (56) iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA . primary_expression BOX_PAR_CLOSE COLON INC_OP compound_statement
    (57) iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA . primary_expression BOX_PAR_CLOSE COLON DEC_OP compound_statement
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    primary_expression             shift and go to state 98
    literal                        shift and go to state 28

state 70

    (54) conditional_expression -> or_expression QUESTION assignment_expression . COLON conditional_expression

    COLON           shift and go to state 99


state 71

    (52) or_expression -> or_expression OR_OP and_expression .
    (50) and_expression -> and_expression . AND_OP equality_expression

    QUESTION        reduce using rule 52 (or_expression -> or_expression OR_OP and_expression .)
    OR_OP           reduce using rule 52 (or_expression -> or_expression OR_OP and_expression .)
    CUR_PAR_OPEN    reduce using rule 52 (or_expression -> or_expression OR_OP and_expression .)
    SEMICOLON       reduce using rule 52 (or_expression -> or_expression OR_OP and_expression .)
    AND_OP          shift and go to state 43


state 72

    (50) and_expression -> and_expression AND_OP equality_expression .
    (47) equality_expression -> equality_expression . EQ_OP relational_expression
    (48) equality_expression -> equality_expression . NE_OP relational_expression

    AND_OP          reduce using rule 50 (and_expression -> and_expression AND_OP equality_expression .)
    QUESTION        reduce using rule 50 (and_expression -> and_expression AND_OP equality_expression .)
    OR_OP           reduce using rule 50 (and_expression -> and_expression AND_OP equality_expression .)
    CUR_PAR_OPEN    reduce using rule 50 (and_expression -> and_expression AND_OP equality_expression .)
    SEMICOLON       reduce using rule 50 (and_expression -> and_expression AND_OP equality_expression .)
    EQ_OP           shift and go to state 44
    NE_OP           shift and go to state 45


state 73

    (47) equality_expression -> equality_expression EQ_OP relational_expression .
    (42) relational_expression -> relational_expression . LESS_OP multiplicative_expression
    (43) relational_expression -> relational_expression . GREATER_OP multiplicative_expression
    (44) relational_expression -> relational_expression . LE_OP multiplicative_expression
    (45) relational_expression -> relational_expression . GE_OP multiplicative_expression

    EQ_OP           reduce using rule 47 (equality_expression -> equality_expression EQ_OP relational_expression .)
    NE_OP           reduce using rule 47 (equality_expression -> equality_expression EQ_OP relational_expression .)
    AND_OP          reduce using rule 47 (equality_expression -> equality_expression EQ_OP relational_expression .)
    QUESTION        reduce using rule 47 (equality_expression -> equality_expression EQ_OP relational_expression .)
    OR_OP           reduce using rule 47 (equality_expression -> equality_expression EQ_OP relational_expression .)
    CUR_PAR_OPEN    reduce using rule 47 (equality_expression -> equality_expression EQ_OP relational_expression .)
    SEMICOLON       reduce using rule 47 (equality_expression -> equality_expression EQ_OP relational_expression .)
    LESS_OP         shift and go to state 46
    GREATER_OP      shift and go to state 47
    LE_OP           shift and go to state 48
    GE_OP           shift and go to state 49


state 74

    (48) equality_expression -> equality_expression NE_OP relational_expression .
    (42) relational_expression -> relational_expression . LESS_OP multiplicative_expression
    (43) relational_expression -> relational_expression . GREATER_OP multiplicative_expression
    (44) relational_expression -> relational_expression . LE_OP multiplicative_expression
    (45) relational_expression -> relational_expression . GE_OP multiplicative_expression

    EQ_OP           reduce using rule 48 (equality_expression -> equality_expression NE_OP relational_expression .)
    NE_OP           reduce using rule 48 (equality_expression -> equality_expression NE_OP relational_expression .)
    AND_OP          reduce using rule 48 (equality_expression -> equality_expression NE_OP relational_expression .)
    QUESTION        reduce using rule 48 (equality_expression -> equality_expression NE_OP relational_expression .)
    OR_OP           reduce using rule 48 (equality_expression -> equality_expression NE_OP relational_expression .)
    CUR_PAR_OPEN    reduce using rule 48 (equality_expression -> equality_expression NE_OP relational_expression .)
    SEMICOLON       reduce using rule 48 (equality_expression -> equality_expression NE_OP relational_expression .)
    LESS_OP         shift and go to state 46
    GREATER_OP      shift and go to state 47
    LE_OP           shift and go to state 48
    GE_OP           shift and go to state 49


state 75

    (42) relational_expression -> relational_expression LESS_OP multiplicative_expression .
    (26) multiplicative_expression -> multiplicative_expression . MUL additive_expression
    (27) multiplicative_expression -> multiplicative_expression . DIV additive_expression

    LESS_OP         reduce using rule 42 (relational_expression -> relational_expression LESS_OP multiplicative_expression .)
    GREATER_OP      reduce using rule 42 (relational_expression -> relational_expression LESS_OP multiplicative_expression .)
    LE_OP           reduce using rule 42 (relational_expression -> relational_expression LESS_OP multiplicative_expression .)
    GE_OP           reduce using rule 42 (relational_expression -> relational_expression LESS_OP multiplicative_expression .)
    EQ_OP           reduce using rule 42 (relational_expression -> relational_expression LESS_OP multiplicative_expression .)
    NE_OP           reduce using rule 42 (relational_expression -> relational_expression LESS_OP multiplicative_expression .)
    AND_OP          reduce using rule 42 (relational_expression -> relational_expression LESS_OP multiplicative_expression .)
    QUESTION        reduce using rule 42 (relational_expression -> relational_expression LESS_OP multiplicative_expression .)
    OR_OP           reduce using rule 42 (relational_expression -> relational_expression LESS_OP multiplicative_expression .)
    CUR_PAR_OPEN    reduce using rule 42 (relational_expression -> relational_expression LESS_OP multiplicative_expression .)
    SEMICOLON       reduce using rule 42 (relational_expression -> relational_expression LESS_OP multiplicative_expression .)
    MUL             shift and go to state 50
    DIV             shift and go to state 51


state 76

    (43) relational_expression -> relational_expression GREATER_OP multiplicative_expression .
    (26) multiplicative_expression -> multiplicative_expression . MUL additive_expression
    (27) multiplicative_expression -> multiplicative_expression . DIV additive_expression

    LESS_OP         reduce using rule 43 (relational_expression -> relational_expression GREATER_OP multiplicative_expression .)
    GREATER_OP      reduce using rule 43 (relational_expression -> relational_expression GREATER_OP multiplicative_expression .)
    LE_OP           reduce using rule 43 (relational_expression -> relational_expression GREATER_OP multiplicative_expression .)
    GE_OP           reduce using rule 43 (relational_expression -> relational_expression GREATER_OP multiplicative_expression .)
    EQ_OP           reduce using rule 43 (relational_expression -> relational_expression GREATER_OP multiplicative_expression .)
    NE_OP           reduce using rule 43 (relational_expression -> relational_expression GREATER_OP multiplicative_expression .)
    AND_OP          reduce using rule 43 (relational_expression -> relational_expression GREATER_OP multiplicative_expression .)
    QUESTION        reduce using rule 43 (relational_expression -> relational_expression GREATER_OP multiplicative_expression .)
    OR_OP           reduce using rule 43 (relational_expression -> relational_expression GREATER_OP multiplicative_expression .)
    CUR_PAR_OPEN    reduce using rule 43 (relational_expression -> relational_expression GREATER_OP multiplicative_expression .)
    SEMICOLON       reduce using rule 43 (relational_expression -> relational_expression GREATER_OP multiplicative_expression .)
    MUL             shift and go to state 50
    DIV             shift and go to state 51


state 77

    (44) relational_expression -> relational_expression LE_OP multiplicative_expression .
    (26) multiplicative_expression -> multiplicative_expression . MUL additive_expression
    (27) multiplicative_expression -> multiplicative_expression . DIV additive_expression

    LESS_OP         reduce using rule 44 (relational_expression -> relational_expression LE_OP multiplicative_expression .)
    GREATER_OP      reduce using rule 44 (relational_expression -> relational_expression LE_OP multiplicative_expression .)
    LE_OP           reduce using rule 44 (relational_expression -> relational_expression LE_OP multiplicative_expression .)
    GE_OP           reduce using rule 44 (relational_expression -> relational_expression LE_OP multiplicative_expression .)
    EQ_OP           reduce using rule 44 (relational_expression -> relational_expression LE_OP multiplicative_expression .)
    NE_OP           reduce using rule 44 (relational_expression -> relational_expression LE_OP multiplicative_expression .)
    AND_OP          reduce using rule 44 (relational_expression -> relational_expression LE_OP multiplicative_expression .)
    QUESTION        reduce using rule 44 (relational_expression -> relational_expression LE_OP multiplicative_expression .)
    OR_OP           reduce using rule 44 (relational_expression -> relational_expression LE_OP multiplicative_expression .)
    CUR_PAR_OPEN    reduce using rule 44 (relational_expression -> relational_expression LE_OP multiplicative_expression .)
    SEMICOLON       reduce using rule 44 (relational_expression -> relational_expression LE_OP multiplicative_expression .)
    MUL             shift and go to state 50
    DIV             shift and go to state 51


state 78

    (45) relational_expression -> relational_expression GE_OP multiplicative_expression .
    (26) multiplicative_expression -> multiplicative_expression . MUL additive_expression
    (27) multiplicative_expression -> multiplicative_expression . DIV additive_expression

    LESS_OP         reduce using rule 45 (relational_expression -> relational_expression GE_OP multiplicative_expression .)
    GREATER_OP      reduce using rule 45 (relational_expression -> relational_expression GE_OP multiplicative_expression .)
    LE_OP           reduce using rule 45 (relational_expression -> relational_expression GE_OP multiplicative_expression .)
    GE_OP           reduce using rule 45 (relational_expression -> relational_expression GE_OP multiplicative_expression .)
    EQ_OP           reduce using rule 45 (relational_expression -> relational_expression GE_OP multiplicative_expression .)
    NE_OP           reduce using rule 45 (relational_expression -> relational_expression GE_OP multiplicative_expression .)
    AND_OP          reduce using rule 45 (relational_expression -> relational_expression GE_OP multiplicative_expression .)
    QUESTION        reduce using rule 45 (relational_expression -> relational_expression GE_OP multiplicative_expression .)
    OR_OP           reduce using rule 45 (relational_expression -> relational_expression GE_OP multiplicative_expression .)
    CUR_PAR_OPEN    reduce using rule 45 (relational_expression -> relational_expression GE_OP multiplicative_expression .)
    SEMICOLON       reduce using rule 45 (relational_expression -> relational_expression GE_OP multiplicative_expression .)
    MUL             shift and go to state 50
    DIV             shift and go to state 51


state 79

    (26) multiplicative_expression -> multiplicative_expression MUL additive_expression .
    (23) additive_expression -> additive_expression . PLUS primary_expression
    (24) additive_expression -> additive_expression . MINUS primary_expression

    MUL             reduce using rule 26 (multiplicative_expression -> multiplicative_expression MUL additive_expression .)
    DIV             reduce using rule 26 (multiplicative_expression -> multiplicative_expression MUL additive_expression .)
    LESS_OP         reduce using rule 26 (multiplicative_expression -> multiplicative_expression MUL additive_expression .)
    GREATER_OP      reduce using rule 26 (multiplicative_expression -> multiplicative_expression MUL additive_expression .)
    LE_OP           reduce using rule 26 (multiplicative_expression -> multiplicative_expression MUL additive_expression .)
    GE_OP           reduce using rule 26 (multiplicative_expression -> multiplicative_expression MUL additive_expression .)
    EQ_OP           reduce using rule 26 (multiplicative_expression -> multiplicative_expression MUL additive_expression .)
    NE_OP           reduce using rule 26 (multiplicative_expression -> multiplicative_expression MUL additive_expression .)
    AND_OP          reduce using rule 26 (multiplicative_expression -> multiplicative_expression MUL additive_expression .)
    QUESTION        reduce using rule 26 (multiplicative_expression -> multiplicative_expression MUL additive_expression .)
    OR_OP           reduce using rule 26 (multiplicative_expression -> multiplicative_expression MUL additive_expression .)
    CUR_PAR_OPEN    reduce using rule 26 (multiplicative_expression -> multiplicative_expression MUL additive_expression .)
    SEMICOLON       reduce using rule 26 (multiplicative_expression -> multiplicative_expression MUL additive_expression .)
    COLON           reduce using rule 26 (multiplicative_expression -> multiplicative_expression MUL additive_expression .)
    PLUS            shift and go to state 52
    MINUS           shift and go to state 53


state 80

    (27) multiplicative_expression -> multiplicative_expression DIV additive_expression .
    (23) additive_expression -> additive_expression . PLUS primary_expression
    (24) additive_expression -> additive_expression . MINUS primary_expression

    MUL             reduce using rule 27 (multiplicative_expression -> multiplicative_expression DIV additive_expression .)
    DIV             reduce using rule 27 (multiplicative_expression -> multiplicative_expression DIV additive_expression .)
    LESS_OP         reduce using rule 27 (multiplicative_expression -> multiplicative_expression DIV additive_expression .)
    GREATER_OP      reduce using rule 27 (multiplicative_expression -> multiplicative_expression DIV additive_expression .)
    LE_OP           reduce using rule 27 (multiplicative_expression -> multiplicative_expression DIV additive_expression .)
    GE_OP           reduce using rule 27 (multiplicative_expression -> multiplicative_expression DIV additive_expression .)
    EQ_OP           reduce using rule 27 (multiplicative_expression -> multiplicative_expression DIV additive_expression .)
    NE_OP           reduce using rule 27 (multiplicative_expression -> multiplicative_expression DIV additive_expression .)
    AND_OP          reduce using rule 27 (multiplicative_expression -> multiplicative_expression DIV additive_expression .)
    QUESTION        reduce using rule 27 (multiplicative_expression -> multiplicative_expression DIV additive_expression .)
    OR_OP           reduce using rule 27 (multiplicative_expression -> multiplicative_expression DIV additive_expression .)
    CUR_PAR_OPEN    reduce using rule 27 (multiplicative_expression -> multiplicative_expression DIV additive_expression .)
    SEMICOLON       reduce using rule 27 (multiplicative_expression -> multiplicative_expression DIV additive_expression .)
    COLON           reduce using rule 27 (multiplicative_expression -> multiplicative_expression DIV additive_expression .)
    PLUS            shift and go to state 52
    MINUS           shift and go to state 53


state 81

    (23) additive_expression -> additive_expression PLUS primary_expression .

    PLUS            reduce using rule 23 (additive_expression -> additive_expression PLUS primary_expression .)
    MINUS           reduce using rule 23 (additive_expression -> additive_expression PLUS primary_expression .)
    MUL             reduce using rule 23 (additive_expression -> additive_expression PLUS primary_expression .)
    DIV             reduce using rule 23 (additive_expression -> additive_expression PLUS primary_expression .)
    LESS_OP         reduce using rule 23 (additive_expression -> additive_expression PLUS primary_expression .)
    GREATER_OP      reduce using rule 23 (additive_expression -> additive_expression PLUS primary_expression .)
    LE_OP           reduce using rule 23 (additive_expression -> additive_expression PLUS primary_expression .)
    GE_OP           reduce using rule 23 (additive_expression -> additive_expression PLUS primary_expression .)
    EQ_OP           reduce using rule 23 (additive_expression -> additive_expression PLUS primary_expression .)
    NE_OP           reduce using rule 23 (additive_expression -> additive_expression PLUS primary_expression .)
    AND_OP          reduce using rule 23 (additive_expression -> additive_expression PLUS primary_expression .)
    QUESTION        reduce using rule 23 (additive_expression -> additive_expression PLUS primary_expression .)
    OR_OP           reduce using rule 23 (additive_expression -> additive_expression PLUS primary_expression .)
    CUR_PAR_OPEN    reduce using rule 23 (additive_expression -> additive_expression PLUS primary_expression .)
    SEMICOLON       reduce using rule 23 (additive_expression -> additive_expression PLUS primary_expression .)
    COLON           reduce using rule 23 (additive_expression -> additive_expression PLUS primary_expression .)


state 82

    (24) additive_expression -> additive_expression MINUS primary_expression .

    PLUS            reduce using rule 24 (additive_expression -> additive_expression MINUS primary_expression .)
    MINUS           reduce using rule 24 (additive_expression -> additive_expression MINUS primary_expression .)
    MUL             reduce using rule 24 (additive_expression -> additive_expression MINUS primary_expression .)
    DIV             reduce using rule 24 (additive_expression -> additive_expression MINUS primary_expression .)
    LESS_OP         reduce using rule 24 (additive_expression -> additive_expression MINUS primary_expression .)
    GREATER_OP      reduce using rule 24 (additive_expression -> additive_expression MINUS primary_expression .)
    LE_OP           reduce using rule 24 (additive_expression -> additive_expression MINUS primary_expression .)
    GE_OP           reduce using rule 24 (additive_expression -> additive_expression MINUS primary_expression .)
    EQ_OP           reduce using rule 24 (additive_expression -> additive_expression MINUS primary_expression .)
    NE_OP           reduce using rule 24 (additive_expression -> additive_expression MINUS primary_expression .)
    AND_OP          reduce using rule 24 (additive_expression -> additive_expression MINUS primary_expression .)
    QUESTION        reduce using rule 24 (additive_expression -> additive_expression MINUS primary_expression .)
    OR_OP           reduce using rule 24 (additive_expression -> additive_expression MINUS primary_expression .)
    CUR_PAR_OPEN    reduce using rule 24 (additive_expression -> additive_expression MINUS primary_expression .)
    SEMICOLON       reduce using rule 24 (additive_expression -> additive_expression MINUS primary_expression .)
    COLON           reduce using rule 24 (additive_expression -> additive_expression MINUS primary_expression .)


state 83

    (59) iteration_statement -> DO compound_statement WHILE conditional_expression . SEMICOLON

    SEMICOLON       shift and go to state 100


state 84

    (38) compound_statement -> CUR_PAR_OPEN statement_list CUR_PAR_CLOSE .

    WHILE           reduce using rule 38 (compound_statement -> CUR_PAR_OPEN statement_list CUR_PAR_CLOSE .)
    LET             reduce using rule 38 (compound_statement -> CUR_PAR_OPEN statement_list CUR_PAR_CLOSE .)
    CONST           reduce using rule 38 (compound_statement -> CUR_PAR_OPEN statement_list CUR_PAR_CLOSE .)
    $end            reduce using rule 38 (compound_statement -> CUR_PAR_OPEN statement_list CUR_PAR_CLOSE .)
    CUR_PAR_CLOSE   reduce using rule 38 (compound_statement -> CUR_PAR_OPEN statement_list CUR_PAR_CLOSE .)
    FROM            reduce using rule 38 (compound_statement -> CUR_PAR_OPEN statement_list CUR_PAR_CLOSE .)
    DO              reduce using rule 38 (compound_statement -> CUR_PAR_OPEN statement_list CUR_PAR_CLOSE .)
    IF              reduce using rule 38 (compound_statement -> CUR_PAR_OPEN statement_list CUR_PAR_CLOSE .)
    ELSE            reduce using rule 38 (compound_statement -> CUR_PAR_OPEN statement_list CUR_PAR_CLOSE .)


state 85

    (36) statement_list -> statement_list statement .

    CUR_PAR_CLOSE   reduce using rule 36 (statement_list -> statement_list statement .)
    FROM            reduce using rule 36 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 36 (statement_list -> statement_list statement .)
    DO              reduce using rule 36 (statement_list -> statement_list statement .)
    IF              reduce using rule 36 (statement_list -> statement_list statement .)
    LET             reduce using rule 36 (statement_list -> statement_list statement .)
    CONST           reduce using rule 36 (statement_list -> statement_list statement .)


state 86

    (31) selection_statement -> IF conditional_expression compound_statement ELSE . compound_statement
    (37) compound_statement -> . CUR_PAR_OPEN CUR_PAR_CLOSE
    (38) compound_statement -> . CUR_PAR_OPEN statement_list CUR_PAR_CLOSE

    CUR_PAR_OPEN    shift and go to state 33

    compound_statement             shift and go to state 101

state 87

    (29) assignment_expression -> primary_expression EQUALS . multiplicative_expression
    (25) multiplicative_expression -> . additive_expression
    (26) multiplicative_expression -> . multiplicative_expression MUL additive_expression
    (27) multiplicative_expression -> . multiplicative_expression DIV additive_expression
    (22) additive_expression -> . primary_expression
    (23) additive_expression -> . additive_expression PLUS primary_expression
    (24) additive_expression -> . additive_expression MINUS primary_expression
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    primary_expression             shift and go to state 26
    multiplicative_expression      shift and go to state 102
    additive_expression            shift and go to state 25
    literal                        shift and go to state 28

state 88

    (9) declarator -> LET IDENTIFIER COLON type_specifier .

    EQUALS          reduce using rule 9 (declarator -> LET IDENTIFIER COLON type_specifier .)
    SEMICOLON       reduce using rule 9 (declarator -> LET IDENTIFIER COLON type_specifier .)


state 89

    (11) type_specifier -> VOID .

    EQUALS          reduce using rule 11 (type_specifier -> VOID .)
    SEMICOLON       reduce using rule 11 (type_specifier -> VOID .)
    CUR_PAR_OPEN    reduce using rule 11 (type_specifier -> VOID .)


state 90

    (12) type_specifier -> CHAR .

    EQUALS          reduce using rule 12 (type_specifier -> CHAR .)
    SEMICOLON       reduce using rule 12 (type_specifier -> CHAR .)
    CUR_PAR_OPEN    reduce using rule 12 (type_specifier -> CHAR .)


state 91

    (13) type_specifier -> INT .

    EQUALS          reduce using rule 13 (type_specifier -> INT .)
    SEMICOLON       reduce using rule 13 (type_specifier -> INT .)
    CUR_PAR_OPEN    reduce using rule 13 (type_specifier -> INT .)


state 92

    (14) type_specifier -> FLOAT .

    EQUALS          reduce using rule 14 (type_specifier -> FLOAT .)
    SEMICOLON       reduce using rule 14 (type_specifier -> FLOAT .)
    CUR_PAR_OPEN    reduce using rule 14 (type_specifier -> FLOAT .)


state 93

    (15) type_specifier -> STRING .

    EQUALS          reduce using rule 15 (type_specifier -> STRING .)
    SEMICOLON       reduce using rule 15 (type_specifier -> STRING .)
    CUR_PAR_OPEN    reduce using rule 15 (type_specifier -> STRING .)


state 94

    (16) type_specifier -> BOOL .

    EQUALS          reduce using rule 16 (type_specifier -> BOOL .)
    SEMICOLON       reduce using rule 16 (type_specifier -> BOOL .)
    CUR_PAR_OPEN    reduce using rule 16 (type_specifier -> BOOL .)


state 95

    (10) declarator -> CONST IDENTIFIER COLON type_specifier .

    EQUALS          reduce using rule 10 (declarator -> CONST IDENTIFIER COLON type_specifier .)
    SEMICOLON       reduce using rule 10 (declarator -> CONST IDENTIFIER COLON type_specifier .)


state 96

    (55) function_definition -> FUNC IDENTIFIER RND_PAR_OPEN identifier_list RND_PAR_CLOSE . ARROW type_specifier compound_statement

    ARROW           shift and go to state 103


state 97

    (40) identifier_list -> identifier_list COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 104


state 98

    (56) iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression . BOX_PAR_CLOSE COLON INC_OP compound_statement
    (57) iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression . BOX_PAR_CLOSE COLON DEC_OP compound_statement

    BOX_PAR_CLOSE   shift and go to state 105


state 99

    (54) conditional_expression -> or_expression QUESTION assignment_expression COLON . conditional_expression
    (53) conditional_expression -> . or_expression
    (54) conditional_expression -> . or_expression QUESTION assignment_expression COLON conditional_expression
    (51) or_expression -> . and_expression
    (52) or_expression -> . or_expression OR_OP and_expression
    (49) and_expression -> . equality_expression
    (50) and_expression -> . and_expression AND_OP equality_expression
    (46) equality_expression -> . relational_expression
    (47) equality_expression -> . equality_expression EQ_OP relational_expression
    (48) equality_expression -> . equality_expression NE_OP relational_expression
    (41) relational_expression -> . multiplicative_expression
    (42) relational_expression -> . relational_expression LESS_OP multiplicative_expression
    (43) relational_expression -> . relational_expression GREATER_OP multiplicative_expression
    (44) relational_expression -> . relational_expression LE_OP multiplicative_expression
    (45) relational_expression -> . relational_expression GE_OP multiplicative_expression
    (25) multiplicative_expression -> . additive_expression
    (26) multiplicative_expression -> . multiplicative_expression MUL additive_expression
    (27) multiplicative_expression -> . multiplicative_expression DIV additive_expression
    (22) additive_expression -> . primary_expression
    (23) additive_expression -> . additive_expression PLUS primary_expression
    (24) additive_expression -> . additive_expression MINUS primary_expression
    (20) primary_expression -> . IDENTIFIER
    (21) primary_expression -> . literal
    (17) literal -> . INT_LITERAL
    (18) literal -> . FLOAT_LITERAL
    (19) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 27
    INT_LITERAL     shift and go to state 29
    FLOAT_LITERAL   shift and go to state 30
    STRING_LITERAL  shift and go to state 31

    or_expression                  shift and go to state 20
    conditional_expression         shift and go to state 106
    and_expression                 shift and go to state 21
    equality_expression            shift and go to state 22
    relational_expression          shift and go to state 23
    multiplicative_expression      shift and go to state 24
    additive_expression            shift and go to state 25
    primary_expression             shift and go to state 26
    literal                        shift and go to state 28

state 100

    (59) iteration_statement -> DO compound_statement WHILE conditional_expression SEMICOLON .

    LET             reduce using rule 59 (iteration_statement -> DO compound_statement WHILE conditional_expression SEMICOLON .)
    CONST           reduce using rule 59 (iteration_statement -> DO compound_statement WHILE conditional_expression SEMICOLON .)
    $end            reduce using rule 59 (iteration_statement -> DO compound_statement WHILE conditional_expression SEMICOLON .)
    CUR_PAR_CLOSE   reduce using rule 59 (iteration_statement -> DO compound_statement WHILE conditional_expression SEMICOLON .)
    FROM            reduce using rule 59 (iteration_statement -> DO compound_statement WHILE conditional_expression SEMICOLON .)
    WHILE           reduce using rule 59 (iteration_statement -> DO compound_statement WHILE conditional_expression SEMICOLON .)
    DO              reduce using rule 59 (iteration_statement -> DO compound_statement WHILE conditional_expression SEMICOLON .)
    IF              reduce using rule 59 (iteration_statement -> DO compound_statement WHILE conditional_expression SEMICOLON .)


state 101

    (31) selection_statement -> IF conditional_expression compound_statement ELSE compound_statement .

    LET             reduce using rule 31 (selection_statement -> IF conditional_expression compound_statement ELSE compound_statement .)
    CONST           reduce using rule 31 (selection_statement -> IF conditional_expression compound_statement ELSE compound_statement .)
    $end            reduce using rule 31 (selection_statement -> IF conditional_expression compound_statement ELSE compound_statement .)
    CUR_PAR_CLOSE   reduce using rule 31 (selection_statement -> IF conditional_expression compound_statement ELSE compound_statement .)
    FROM            reduce using rule 31 (selection_statement -> IF conditional_expression compound_statement ELSE compound_statement .)
    WHILE           reduce using rule 31 (selection_statement -> IF conditional_expression compound_statement ELSE compound_statement .)
    DO              reduce using rule 31 (selection_statement -> IF conditional_expression compound_statement ELSE compound_statement .)
    IF              reduce using rule 31 (selection_statement -> IF conditional_expression compound_statement ELSE compound_statement .)


state 102

    (29) assignment_expression -> primary_expression EQUALS multiplicative_expression .
    (26) multiplicative_expression -> multiplicative_expression . MUL additive_expression
    (27) multiplicative_expression -> multiplicative_expression . DIV additive_expression

    SEMICOLON       reduce using rule 29 (assignment_expression -> primary_expression EQUALS multiplicative_expression .)
    COLON           reduce using rule 29 (assignment_expression -> primary_expression EQUALS multiplicative_expression .)
    MUL             shift and go to state 50
    DIV             shift and go to state 51


state 103

    (55) function_definition -> FUNC IDENTIFIER RND_PAR_OPEN identifier_list RND_PAR_CLOSE ARROW . type_specifier compound_statement
    (11) type_specifier -> . VOID
    (12) type_specifier -> . CHAR
    (13) type_specifier -> . INT
    (14) type_specifier -> . FLOAT
    (15) type_specifier -> . STRING
    (16) type_specifier -> . BOOL

    VOID            shift and go to state 89
    CHAR            shift and go to state 90
    INT             shift and go to state 91
    FLOAT           shift and go to state 92
    STRING          shift and go to state 93
    BOOL            shift and go to state 94

    type_specifier                 shift and go to state 107

state 104

    (40) identifier_list -> identifier_list COMMA IDENTIFIER .

    RND_PAR_CLOSE   reduce using rule 40 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    COMMA           reduce using rule 40 (identifier_list -> identifier_list COMMA IDENTIFIER .)


state 105

    (56) iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE . COLON INC_OP compound_statement
    (57) iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE . COLON DEC_OP compound_statement

    COLON           shift and go to state 108


state 106

    (54) conditional_expression -> or_expression QUESTION assignment_expression COLON conditional_expression .

    CUR_PAR_OPEN    reduce using rule 54 (conditional_expression -> or_expression QUESTION assignment_expression COLON conditional_expression .)
    SEMICOLON       reduce using rule 54 (conditional_expression -> or_expression QUESTION assignment_expression COLON conditional_expression .)


state 107

    (55) function_definition -> FUNC IDENTIFIER RND_PAR_OPEN identifier_list RND_PAR_CLOSE ARROW type_specifier . compound_statement
    (37) compound_statement -> . CUR_PAR_OPEN CUR_PAR_CLOSE
    (38) compound_statement -> . CUR_PAR_OPEN statement_list CUR_PAR_CLOSE

    CUR_PAR_OPEN    shift and go to state 33

    compound_statement             shift and go to state 109

state 108

    (56) iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON . INC_OP compound_statement
    (57) iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON . DEC_OP compound_statement

    INC_OP          shift and go to state 110
    DEC_OP          shift and go to state 111


state 109

    (55) function_definition -> FUNC IDENTIFIER RND_PAR_OPEN identifier_list RND_PAR_CLOSE ARROW type_specifier compound_statement .

    LET             reduce using rule 55 (function_definition -> FUNC IDENTIFIER RND_PAR_OPEN identifier_list RND_PAR_CLOSE ARROW type_specifier compound_statement .)
    CONST           reduce using rule 55 (function_definition -> FUNC IDENTIFIER RND_PAR_OPEN identifier_list RND_PAR_CLOSE ARROW type_specifier compound_statement .)
    $end            reduce using rule 55 (function_definition -> FUNC IDENTIFIER RND_PAR_OPEN identifier_list RND_PAR_CLOSE ARROW type_specifier compound_statement .)


state 110

    (56) iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON INC_OP . compound_statement
    (37) compound_statement -> . CUR_PAR_OPEN CUR_PAR_CLOSE
    (38) compound_statement -> . CUR_PAR_OPEN statement_list CUR_PAR_CLOSE

    CUR_PAR_OPEN    shift and go to state 33

    compound_statement             shift and go to state 112

state 111

    (57) iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON DEC_OP . compound_statement
    (37) compound_statement -> . CUR_PAR_OPEN CUR_PAR_CLOSE
    (38) compound_statement -> . CUR_PAR_OPEN statement_list CUR_PAR_CLOSE

    CUR_PAR_OPEN    shift and go to state 33

    compound_statement             shift and go to state 113

state 112

    (56) iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON INC_OP compound_statement .

    LET             reduce using rule 56 (iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON INC_OP compound_statement .)
    CONST           reduce using rule 56 (iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON INC_OP compound_statement .)
    $end            reduce using rule 56 (iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON INC_OP compound_statement .)
    CUR_PAR_CLOSE   reduce using rule 56 (iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON INC_OP compound_statement .)
    FROM            reduce using rule 56 (iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON INC_OP compound_statement .)
    WHILE           reduce using rule 56 (iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON INC_OP compound_statement .)
    DO              reduce using rule 56 (iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON INC_OP compound_statement .)
    IF              reduce using rule 56 (iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON INC_OP compound_statement .)


state 113

    (57) iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON DEC_OP compound_statement .

    LET             reduce using rule 57 (iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON DEC_OP compound_statement .)
    CONST           reduce using rule 57 (iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON DEC_OP compound_statement .)
    $end            reduce using rule 57 (iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON DEC_OP compound_statement .)
    CUR_PAR_CLOSE   reduce using rule 57 (iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON DEC_OP compound_statement .)
    FROM            reduce using rule 57 (iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON DEC_OP compound_statement .)
    WHILE           reduce using rule 57 (iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON DEC_OP compound_statement .)
    DO              reduce using rule 57 (iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON DEC_OP compound_statement .)
    IF              reduce using rule 57 (iteration_statement -> FROM BOX_PAR_OPEN primary_expression COMMA primary_expression BOX_PAR_CLOSE COLON DEC_OP compound_statement .)


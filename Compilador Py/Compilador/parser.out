Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND_OP
    ARROW
    BOX_PAR_CLOSE
    BOX_PAR_OPEN
    COMMA
    CUR_PAR_CLOSE
    CUR_PAR_OPEN
    DEC_OP
    ELSE
    EQ_OP
    FUNC
    GE_OP
    IF
    INC_OP
    LE_OP
    NE_OP
    OR_OP
    RND_PAR_CLOSE
    RND_PAR_OPEN

Grammar

Rule 0     S' -> program
Rule 1     program -> declaration
Rule 2     program -> program declaration
Rule 3     declaration -> init_declarator SEMICOLON
Rule 4     init_declarator -> declarator
Rule 5     init_declarator -> declarator EQUALS assignment_expression
Rule 6     declarator -> LET IDENTIFIER COLON type_specifier
Rule 7     declarator -> CONST IDENTIFIER COLON type_specifier
Rule 8     type_specifier -> VOID
Rule 9     type_specifier -> CHAR
Rule 10    type_specifier -> INT
Rule 11    type_specifier -> FLOAT
Rule 12    type_specifier -> STRING
Rule 13    type_specifier -> BOOL
Rule 14    literal -> INT_LITERAL
Rule 15    literal -> FLOAT_LITERAL
Rule 16    literal -> STRING_LITERAL
Rule 17    primary_expression -> IDENTIFIER
Rule 18    primary_expression -> literal
Rule 19    additive_expression -> primary_expression
Rule 20    additive_expression -> additive_expression PLUS primary_expression
Rule 21    additive_expression -> additive_expression MINUS primary_expression
Rule 22    multiplicative_expression -> additive_expression
Rule 23    multiplicative_expression -> multiplicative_expression MUL additive_expression
Rule 24    multiplicative_expression -> multiplicative_expression DIV additive_expression
Rule 25    assignment_expression -> multiplicative_expression
Rule 26    assignment_expression -> primary_expression EQUALS multiplicative_expression

Terminals, with rules where they appear

AND_OP               : 
ARROW                : 
BOOL                 : 13
BOX_PAR_CLOSE        : 
BOX_PAR_OPEN         : 
CHAR                 : 9
COLON                : 6 7
COMMA                : 
CONST                : 7
CUR_PAR_CLOSE        : 
CUR_PAR_OPEN         : 
DEC_OP               : 
DIV                  : 24
ELSE                 : 
EQUALS               : 5 26
EQ_OP                : 
FLOAT                : 11
FLOAT_LITERAL        : 15
FUNC                 : 
GE_OP                : 
IDENTIFIER           : 6 7 17
IF                   : 
INC_OP               : 
INT                  : 10
INT_LITERAL          : 14
LET                  : 6
LE_OP                : 
MINUS                : 21
MUL                  : 23
NE_OP                : 
OR_OP                : 
PLUS                 : 20
RND_PAR_CLOSE        : 
RND_PAR_OPEN         : 
SEMICOLON            : 3
STRING               : 12
STRING_LITERAL       : 16
VOID                 : 8
error                : 

Nonterminals, with rules where they appear

additive_expression  : 20 21 22 23 24
assignment_expression : 5
declaration          : 1 2
declarator           : 4 5
init_declarator      : 3
literal              : 18
multiplicative_expression : 23 24 25 26
primary_expression   : 19 20 21 26
program              : 2 0
type_specifier       : 6 7

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declaration
    (2) program -> . program declaration
    (3) declaration -> . init_declarator SEMICOLON
    (4) init_declarator -> . declarator
    (5) init_declarator -> . declarator EQUALS assignment_expression
    (6) declarator -> . LET IDENTIFIER COLON type_specifier
    (7) declarator -> . CONST IDENTIFIER COLON type_specifier

    LET             shift and go to state 5
    CONST           shift and go to state 6

    program                        shift and go to state 1
    declaration                    shift and go to state 2
    init_declarator                shift and go to state 3
    declarator                     shift and go to state 4

state 1

    (0) S' -> program .
    (2) program -> program . declaration
    (3) declaration -> . init_declarator SEMICOLON
    (4) init_declarator -> . declarator
    (5) init_declarator -> . declarator EQUALS assignment_expression
    (6) declarator -> . LET IDENTIFIER COLON type_specifier
    (7) declarator -> . CONST IDENTIFIER COLON type_specifier

    LET             shift and go to state 5
    CONST           shift and go to state 6

    declaration                    shift and go to state 7
    init_declarator                shift and go to state 3
    declarator                     shift and go to state 4

state 2

    (1) program -> declaration .

    LET             reduce using rule 1 (program -> declaration .)
    CONST           reduce using rule 1 (program -> declaration .)
    $end            reduce using rule 1 (program -> declaration .)


state 3

    (3) declaration -> init_declarator . SEMICOLON

    SEMICOLON       shift and go to state 8


state 4

    (4) init_declarator -> declarator .
    (5) init_declarator -> declarator . EQUALS assignment_expression

    SEMICOLON       reduce using rule 4 (init_declarator -> declarator .)
    EQUALS          shift and go to state 9


state 5

    (6) declarator -> LET . IDENTIFIER COLON type_specifier

    IDENTIFIER      shift and go to state 10


state 6

    (7) declarator -> CONST . IDENTIFIER COLON type_specifier

    IDENTIFIER      shift and go to state 11


state 7

    (2) program -> program declaration .

    LET             reduce using rule 2 (program -> program declaration .)
    CONST           reduce using rule 2 (program -> program declaration .)
    $end            reduce using rule 2 (program -> program declaration .)


state 8

    (3) declaration -> init_declarator SEMICOLON .

    LET             reduce using rule 3 (declaration -> init_declarator SEMICOLON .)
    CONST           reduce using rule 3 (declaration -> init_declarator SEMICOLON .)
    $end            reduce using rule 3 (declaration -> init_declarator SEMICOLON .)


state 9

    (5) init_declarator -> declarator EQUALS . assignment_expression
    (25) assignment_expression -> . multiplicative_expression
    (26) assignment_expression -> . primary_expression EQUALS multiplicative_expression
    (22) multiplicative_expression -> . additive_expression
    (23) multiplicative_expression -> . multiplicative_expression MUL additive_expression
    (24) multiplicative_expression -> . multiplicative_expression DIV additive_expression
    (17) primary_expression -> . IDENTIFIER
    (18) primary_expression -> . literal
    (19) additive_expression -> . primary_expression
    (20) additive_expression -> . additive_expression PLUS primary_expression
    (21) additive_expression -> . additive_expression MINUS primary_expression
    (14) literal -> . INT_LITERAL
    (15) literal -> . FLOAT_LITERAL
    (16) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 16
    INT_LITERAL     shift and go to state 18
    FLOAT_LITERAL   shift and go to state 19
    STRING_LITERAL  shift and go to state 20

    assignment_expression          shift and go to state 12
    multiplicative_expression      shift and go to state 13
    primary_expression             shift and go to state 14
    additive_expression            shift and go to state 15
    literal                        shift and go to state 17

state 10

    (6) declarator -> LET IDENTIFIER . COLON type_specifier

    COLON           shift and go to state 21


state 11

    (7) declarator -> CONST IDENTIFIER . COLON type_specifier

    COLON           shift and go to state 22


state 12

    (5) init_declarator -> declarator EQUALS assignment_expression .

    SEMICOLON       reduce using rule 5 (init_declarator -> declarator EQUALS assignment_expression .)


state 13

    (25) assignment_expression -> multiplicative_expression .
    (23) multiplicative_expression -> multiplicative_expression . MUL additive_expression
    (24) multiplicative_expression -> multiplicative_expression . DIV additive_expression

    SEMICOLON       reduce using rule 25 (assignment_expression -> multiplicative_expression .)
    MUL             shift and go to state 23
    DIV             shift and go to state 24


state 14

    (26) assignment_expression -> primary_expression . EQUALS multiplicative_expression
    (19) additive_expression -> primary_expression .

    EQUALS          shift and go to state 25
    PLUS            reduce using rule 19 (additive_expression -> primary_expression .)
    MINUS           reduce using rule 19 (additive_expression -> primary_expression .)
    MUL             reduce using rule 19 (additive_expression -> primary_expression .)
    DIV             reduce using rule 19 (additive_expression -> primary_expression .)
    SEMICOLON       reduce using rule 19 (additive_expression -> primary_expression .)


state 15

    (22) multiplicative_expression -> additive_expression .
    (20) additive_expression -> additive_expression . PLUS primary_expression
    (21) additive_expression -> additive_expression . MINUS primary_expression

    MUL             reduce using rule 22 (multiplicative_expression -> additive_expression .)
    DIV             reduce using rule 22 (multiplicative_expression -> additive_expression .)
    SEMICOLON       reduce using rule 22 (multiplicative_expression -> additive_expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27


state 16

    (17) primary_expression -> IDENTIFIER .

    EQUALS          reduce using rule 17 (primary_expression -> IDENTIFIER .)
    PLUS            reduce using rule 17 (primary_expression -> IDENTIFIER .)
    MINUS           reduce using rule 17 (primary_expression -> IDENTIFIER .)
    MUL             reduce using rule 17 (primary_expression -> IDENTIFIER .)
    DIV             reduce using rule 17 (primary_expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 17 (primary_expression -> IDENTIFIER .)


state 17

    (18) primary_expression -> literal .

    EQUALS          reduce using rule 18 (primary_expression -> literal .)
    PLUS            reduce using rule 18 (primary_expression -> literal .)
    MINUS           reduce using rule 18 (primary_expression -> literal .)
    MUL             reduce using rule 18 (primary_expression -> literal .)
    DIV             reduce using rule 18 (primary_expression -> literal .)
    SEMICOLON       reduce using rule 18 (primary_expression -> literal .)


state 18

    (14) literal -> INT_LITERAL .

    EQUALS          reduce using rule 14 (literal -> INT_LITERAL .)
    PLUS            reduce using rule 14 (literal -> INT_LITERAL .)
    MINUS           reduce using rule 14 (literal -> INT_LITERAL .)
    MUL             reduce using rule 14 (literal -> INT_LITERAL .)
    DIV             reduce using rule 14 (literal -> INT_LITERAL .)
    SEMICOLON       reduce using rule 14 (literal -> INT_LITERAL .)


state 19

    (15) literal -> FLOAT_LITERAL .

    EQUALS          reduce using rule 15 (literal -> FLOAT_LITERAL .)
    PLUS            reduce using rule 15 (literal -> FLOAT_LITERAL .)
    MINUS           reduce using rule 15 (literal -> FLOAT_LITERAL .)
    MUL             reduce using rule 15 (literal -> FLOAT_LITERAL .)
    DIV             reduce using rule 15 (literal -> FLOAT_LITERAL .)
    SEMICOLON       reduce using rule 15 (literal -> FLOAT_LITERAL .)


state 20

    (16) literal -> STRING_LITERAL .

    EQUALS          reduce using rule 16 (literal -> STRING_LITERAL .)
    PLUS            reduce using rule 16 (literal -> STRING_LITERAL .)
    MINUS           reduce using rule 16 (literal -> STRING_LITERAL .)
    MUL             reduce using rule 16 (literal -> STRING_LITERAL .)
    DIV             reduce using rule 16 (literal -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 16 (literal -> STRING_LITERAL .)


state 21

    (6) declarator -> LET IDENTIFIER COLON . type_specifier
    (8) type_specifier -> . VOID
    (9) type_specifier -> . CHAR
    (10) type_specifier -> . INT
    (11) type_specifier -> . FLOAT
    (12) type_specifier -> . STRING
    (13) type_specifier -> . BOOL

    VOID            shift and go to state 29
    CHAR            shift and go to state 30
    INT             shift and go to state 31
    FLOAT           shift and go to state 32
    STRING          shift and go to state 33
    BOOL            shift and go to state 34

    type_specifier                 shift and go to state 28

state 22

    (7) declarator -> CONST IDENTIFIER COLON . type_specifier
    (8) type_specifier -> . VOID
    (9) type_specifier -> . CHAR
    (10) type_specifier -> . INT
    (11) type_specifier -> . FLOAT
    (12) type_specifier -> . STRING
    (13) type_specifier -> . BOOL

    VOID            shift and go to state 29
    CHAR            shift and go to state 30
    INT             shift and go to state 31
    FLOAT           shift and go to state 32
    STRING          shift and go to state 33
    BOOL            shift and go to state 34

    type_specifier                 shift and go to state 35

state 23

    (23) multiplicative_expression -> multiplicative_expression MUL . additive_expression
    (19) additive_expression -> . primary_expression
    (20) additive_expression -> . additive_expression PLUS primary_expression
    (21) additive_expression -> . additive_expression MINUS primary_expression
    (17) primary_expression -> . IDENTIFIER
    (18) primary_expression -> . literal
    (14) literal -> . INT_LITERAL
    (15) literal -> . FLOAT_LITERAL
    (16) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 16
    INT_LITERAL     shift and go to state 18
    FLOAT_LITERAL   shift and go to state 19
    STRING_LITERAL  shift and go to state 20

    additive_expression            shift and go to state 36
    primary_expression             shift and go to state 37
    literal                        shift and go to state 17

state 24

    (24) multiplicative_expression -> multiplicative_expression DIV . additive_expression
    (19) additive_expression -> . primary_expression
    (20) additive_expression -> . additive_expression PLUS primary_expression
    (21) additive_expression -> . additive_expression MINUS primary_expression
    (17) primary_expression -> . IDENTIFIER
    (18) primary_expression -> . literal
    (14) literal -> . INT_LITERAL
    (15) literal -> . FLOAT_LITERAL
    (16) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 16
    INT_LITERAL     shift and go to state 18
    FLOAT_LITERAL   shift and go to state 19
    STRING_LITERAL  shift and go to state 20

    additive_expression            shift and go to state 38
    primary_expression             shift and go to state 37
    literal                        shift and go to state 17

state 25

    (26) assignment_expression -> primary_expression EQUALS . multiplicative_expression
    (22) multiplicative_expression -> . additive_expression
    (23) multiplicative_expression -> . multiplicative_expression MUL additive_expression
    (24) multiplicative_expression -> . multiplicative_expression DIV additive_expression
    (19) additive_expression -> . primary_expression
    (20) additive_expression -> . additive_expression PLUS primary_expression
    (21) additive_expression -> . additive_expression MINUS primary_expression
    (17) primary_expression -> . IDENTIFIER
    (18) primary_expression -> . literal
    (14) literal -> . INT_LITERAL
    (15) literal -> . FLOAT_LITERAL
    (16) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 16
    INT_LITERAL     shift and go to state 18
    FLOAT_LITERAL   shift and go to state 19
    STRING_LITERAL  shift and go to state 20

    primary_expression             shift and go to state 37
    multiplicative_expression      shift and go to state 39
    additive_expression            shift and go to state 15
    literal                        shift and go to state 17

state 26

    (20) additive_expression -> additive_expression PLUS . primary_expression
    (17) primary_expression -> . IDENTIFIER
    (18) primary_expression -> . literal
    (14) literal -> . INT_LITERAL
    (15) literal -> . FLOAT_LITERAL
    (16) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 16
    INT_LITERAL     shift and go to state 18
    FLOAT_LITERAL   shift and go to state 19
    STRING_LITERAL  shift and go to state 20

    primary_expression             shift and go to state 40
    literal                        shift and go to state 17

state 27

    (21) additive_expression -> additive_expression MINUS . primary_expression
    (17) primary_expression -> . IDENTIFIER
    (18) primary_expression -> . literal
    (14) literal -> . INT_LITERAL
    (15) literal -> . FLOAT_LITERAL
    (16) literal -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 16
    INT_LITERAL     shift and go to state 18
    FLOAT_LITERAL   shift and go to state 19
    STRING_LITERAL  shift and go to state 20

    primary_expression             shift and go to state 41
    literal                        shift and go to state 17

state 28

    (6) declarator -> LET IDENTIFIER COLON type_specifier .

    EQUALS          reduce using rule 6 (declarator -> LET IDENTIFIER COLON type_specifier .)
    SEMICOLON       reduce using rule 6 (declarator -> LET IDENTIFIER COLON type_specifier .)


state 29

    (8) type_specifier -> VOID .

    EQUALS          reduce using rule 8 (type_specifier -> VOID .)
    SEMICOLON       reduce using rule 8 (type_specifier -> VOID .)


state 30

    (9) type_specifier -> CHAR .

    EQUALS          reduce using rule 9 (type_specifier -> CHAR .)
    SEMICOLON       reduce using rule 9 (type_specifier -> CHAR .)


state 31

    (10) type_specifier -> INT .

    EQUALS          reduce using rule 10 (type_specifier -> INT .)
    SEMICOLON       reduce using rule 10 (type_specifier -> INT .)


state 32

    (11) type_specifier -> FLOAT .

    EQUALS          reduce using rule 11 (type_specifier -> FLOAT .)
    SEMICOLON       reduce using rule 11 (type_specifier -> FLOAT .)


state 33

    (12) type_specifier -> STRING .

    EQUALS          reduce using rule 12 (type_specifier -> STRING .)
    SEMICOLON       reduce using rule 12 (type_specifier -> STRING .)


state 34

    (13) type_specifier -> BOOL .

    EQUALS          reduce using rule 13 (type_specifier -> BOOL .)
    SEMICOLON       reduce using rule 13 (type_specifier -> BOOL .)


state 35

    (7) declarator -> CONST IDENTIFIER COLON type_specifier .

    EQUALS          reduce using rule 7 (declarator -> CONST IDENTIFIER COLON type_specifier .)
    SEMICOLON       reduce using rule 7 (declarator -> CONST IDENTIFIER COLON type_specifier .)


state 36

    (23) multiplicative_expression -> multiplicative_expression MUL additive_expression .
    (20) additive_expression -> additive_expression . PLUS primary_expression
    (21) additive_expression -> additive_expression . MINUS primary_expression

    MUL             reduce using rule 23 (multiplicative_expression -> multiplicative_expression MUL additive_expression .)
    DIV             reduce using rule 23 (multiplicative_expression -> multiplicative_expression MUL additive_expression .)
    SEMICOLON       reduce using rule 23 (multiplicative_expression -> multiplicative_expression MUL additive_expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27


state 37

    (19) additive_expression -> primary_expression .

    PLUS            reduce using rule 19 (additive_expression -> primary_expression .)
    MINUS           reduce using rule 19 (additive_expression -> primary_expression .)
    MUL             reduce using rule 19 (additive_expression -> primary_expression .)
    DIV             reduce using rule 19 (additive_expression -> primary_expression .)
    SEMICOLON       reduce using rule 19 (additive_expression -> primary_expression .)


state 38

    (24) multiplicative_expression -> multiplicative_expression DIV additive_expression .
    (20) additive_expression -> additive_expression . PLUS primary_expression
    (21) additive_expression -> additive_expression . MINUS primary_expression

    MUL             reduce using rule 24 (multiplicative_expression -> multiplicative_expression DIV additive_expression .)
    DIV             reduce using rule 24 (multiplicative_expression -> multiplicative_expression DIV additive_expression .)
    SEMICOLON       reduce using rule 24 (multiplicative_expression -> multiplicative_expression DIV additive_expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27


state 39

    (26) assignment_expression -> primary_expression EQUALS multiplicative_expression .
    (23) multiplicative_expression -> multiplicative_expression . MUL additive_expression
    (24) multiplicative_expression -> multiplicative_expression . DIV additive_expression

    SEMICOLON       reduce using rule 26 (assignment_expression -> primary_expression EQUALS multiplicative_expression .)
    MUL             shift and go to state 23
    DIV             shift and go to state 24


state 40

    (20) additive_expression -> additive_expression PLUS primary_expression .

    PLUS            reduce using rule 20 (additive_expression -> additive_expression PLUS primary_expression .)
    MINUS           reduce using rule 20 (additive_expression -> additive_expression PLUS primary_expression .)
    MUL             reduce using rule 20 (additive_expression -> additive_expression PLUS primary_expression .)
    DIV             reduce using rule 20 (additive_expression -> additive_expression PLUS primary_expression .)
    SEMICOLON       reduce using rule 20 (additive_expression -> additive_expression PLUS primary_expression .)


state 41

    (21) additive_expression -> additive_expression MINUS primary_expression .

    PLUS            reduce using rule 21 (additive_expression -> additive_expression MINUS primary_expression .)
    MINUS           reduce using rule 21 (additive_expression -> additive_expression MINUS primary_expression .)
    MUL             reduce using rule 21 (additive_expression -> additive_expression MINUS primary_expression .)
    DIV             reduce using rule 21 (additive_expression -> additive_expression MINUS primary_expression .)
    SEMICOLON       reduce using rule 21 (additive_expression -> additive_expression MINUS primary_expression .)

